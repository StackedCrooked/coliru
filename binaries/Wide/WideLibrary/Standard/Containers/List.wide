module Standard {
    module Containers {
        List(ty) {
            node := type {
                type(decltype(value)->decay val) : next(null) : value(move(val)) {}
                next := this->pointer;
                value := ty;
            };
            return type {
               begin := node->pointer;

               type() : begin(null) {}
               type(this->decay->rvalue other) : begin(other.begin) { other.begin = null; }

               ~type() {
                   val := begin;
                   while(val) {
                       next := val->next;
                       val->~type();
                       std.free(reinterpret_cast(decltype(std.malloc(5))->decay, val));
                       val = next;
                   }
               }
               
               All() {
                   pointer := begin;
                   return function() {
                       if (pointer) {
                           ret := Standard.Containers.Optional!(decltype(pointer->value)->decay)(pointer->value);
                           pointer = pointer->next;
                           return ret;
                       }
                       return Standard.Containers.None;
                    };
                }

                End() {
                    pointer := begin;
                    return function() {
                        return Standard.Containers.Optional!(decltype(pointer->value)->decay)(Containers.None);
                    };
                }
            }; 
        }
    }
}