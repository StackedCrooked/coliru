xargs: `/dev/null': No such file or directory
// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Macro to expand parameter packs in expressions for their side-effects

#ifndef WHEELS_EXPAND_HPP
#define WHEELS_EXPAND_HPP

#include <initializer_list>

// NOTE: not simply a void expression to make clang happy.
//       Should not make much difference
#define WHEELS_EXPAND_SIDE_EFFECTS(...) \
    do { \
        auto x = { ((__VA_ARGS__), void(), 0)... }; \
        (void)x; \
    } while(false)

#endif // WHEELS_EXPAND_HPP


// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Macro for abusing ranged-for

#ifndef WHEELS_WITH_HPP
#define WHEELS_WITH_HPP

#define WITH(...) for(__VA_ARGS__)

#endif // WHEELS_WITH_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// A box that enforces the use of a lock to access a value

#ifndef WHEELS_LAZY_HPP
#define WHEELS_LAZY_HPP

#include "meta.h++"

#include <utility>

namespace wheels {
    //! Evaluates an eager argument
    template <typename T , typename Eager,
              EnableIf<std::is_convertible<Eager, T>> = _>
    T lazy(Eager&& value) {
        return std::forward<Eager>(value);
    }

    //! Evaluates a lazy argument
    template <typename T , typename Lazy,
              DisableIf<std::is_convertible<Lazy, T>> = _>
    T lazy(Lazy&& value) {
        return std::forward<Lazy>(value)();
    }
}

#endif // WHEELS_LAZY_HPP


// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Scope guards

#ifndef WHEELS_SCOPE_HPP
#define WHEELS_SCOPE_HPP

#include "meta.h++"

#include <exception>

namespace wheels {
    namespace scope_detail {
        template <typename Fun>
        class guard {
        public:
            template <typename U,
                      DisableIf<is_related<guard, U>> = _>
            explicit guard(U&& u) : fun(std::forward<U>(u)) {}

            guard(guard&& that)
            : on(that.on)
            , fun(std::move(that.fun)) {
                that.on = false;
            }

            ~guard() {
                if(on) fun();
            }
        private:
            bool on = true;
            Fun fun;
        };
    } // namespace scope_detail

    template <typename Fun,
              typename Guard = scope_detail::guard<Decay<Fun>>>
    Guard finally(Fun&& fun) {
        return Guard { std::forward<Fun>(fun) };
    }
} // namespace wheels

#endif // WHEELS_SCOPE_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// std::string literals

#ifndef WHEELS_LITERAL_STRING_HPP
#define WHEELS_LITERAL_STRING_HPP

#include <cstddef>

#include <string>

namespace wheels {
    namespace literal {
        namespace string {
            //! std::string literal
            inline std::string operator"" _s(char const* str, std::size_t n) {
                return { str, n };
            }
            //! std::wstring literal
            inline std::wstring operator"" _s(wchar_t const* str, std::size_t n) {
                return { str, n };
            }
            //! std::u16string literal
            inline std::u16string operator"" _s(char16_t const* str, std::size_t n) {
                return { str, n };
            }
            //! std::u32string literal
            inline std::u32string operator"" _s(char32_t const* str, std::size_t n) {
                return { str, n };
            }
        } // namespace string
    } // namespace literal
} // namespace wheels

#endif // WHEELS_LITERAL_STRING_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Named parameter tools

#ifndef WHEELS_NAMED_PARAM_HPP
#define WHEELS_NAMED_PARAM_HPP

#include "meta.h++"

#define WHEELS_DEFINE_NAMED_PARAMETER(NAME) \
    struct NAME##_name : ::wheels::named_parameter_detail::name<NAME##_name> { \
        using ::wheels::named_parameter_detail::name<NAME##_name>::operator=; \
    } constexpr NAME {}; \
    template <typename T> \
    using NAME##_parameter = ::wheels::named_parameter<NAME##_name, T>; \
    WHEELS_EXPECT_SEMICOLON

namespace wheels {
    template <typename Name, typename T>
    struct named_parameter {
    public:
        static_assert(std::is_reference<T>::value, "T must be a reference type");
        static_assert(is_bare<Name>::value, "Name must be a bare type");

        using name = Name;
        using type = T;

        constexpr named_parameter(T t) : value(std::forward<T>(t)) {}

        named_parameter& operator=(named_parameter const&) = delete;

        T forward() const { return std::forward<T>(value); }

    private:
        T value;
    };

    template <typename Param>
    using ParameterName = typename Param::name;
    template <typename Param>
    using ParameterType = typename Param::type;

    template <typename Name, typename... T>
    struct has_parameter : Any<std::is_same<ParameterName<T>, Name>...> {};

    template <typename Name, typename... T>
    struct get_parameter {};
    template <typename Name, typename Head, typename... Tail>
    struct get_parameter<Name, Head, Tail...>
    : Conditional<
        std::is_same<ParameterName<Head>, Name>,
        identity<Head>,
        get_parameter<Name, Tail...>
    > {};
    template <typename Name, typename... T>
    using GetParameter = Invoke<get_parameter<Name, T...>>;
    template <typename Name, typename... T>
    using GetParameterType = ParameterType<GetParameter<Name, T...>>;

    namespace named_parameter_detail {
        template <typename Name>
        struct name {
            constexpr name() = default;
            template <typename T>
            constexpr named_parameter<Name, T&&> operator=(T&& t) const {
                return { std::forward<T>(t) };
            }
            name(name const&) = delete;
            name& operator=(name const&) = delete;
        };
    } // namespace named_parameter_detail

    template <typename T>
    struct is_named_parameter : is_specialization_of<T, named_parameter> {};

    template <typename... T>
    struct no_named_parameters : Not<Any<is_named_parameter<T>...>> {};

    template <typename... T>
    struct named_parameter_count : count<is_named_parameter<T>...> {};

    template <typename Name, typename Head, typename... Tail>
    Head forward_named(Name const&, named_parameter<Name, Head> const& param, Tail const&...) {
        return param.forward();
    }

    template <typename Name, typename Head, typename... Tail>
    auto forward_named(Name const& name, Head const&, Tail const&... tail)
    -> decltype(forward_named(name, tail...)) {
        return forward_named(name, tail...);
    }
} // namespace wheels

#endif // WHEELS_NAMED_PARAM_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Smart pointer with value semantics

#ifndef WHEELS_SMART_PTR_VALUE_PTR_HPP
#define WHEELS_SMART_PTR_VALUE_PTR_HPP

#include "../allocator.h++"
#include "../meta.h++"
#include "../named_param.h++"
#include "../detail/pointer_param.h++"
#include "../tuple.h++"

#include <boost/operators.hpp>

#include <cstddef>

#include <functional>
#include <memory>
#include <new>
#include <tuple>
#include <utility>

namespace wheels {
    //! Cloning policy that invokes the copy constructor
    template <typename T>
    struct copy_constructor_cloner {
        T* operator()(T* ptr) const {
            return new T(*ptr);
        }
    };
    //! Cloning policy that calls a clone() member function
    template <typename T>
    struct clone_function_cloner {
        constexpr clone_function_cloner() noexcept = default;

        template <typename U,
                  EnableIf<std::is_base_of<T*, U*>> = _>
        clone_function_cloner(clone_function_cloner<U> const&) noexcept {}

        T* operator()(T* ptr) const {
            return ptr->clone();
        }
    };

    namespace value_ptr_detail {
        template <typename T, T* (T::*)() const = &T::clone>
        class cloneable;
    } // namespace value_ptr_detail

    template <typename T, typename = void>
    struct is_cloneable : Bool<false> {};
    template <typename T>
    struct is_cloneable<T, Void<decltype(static_cast<T*>(std::declval<T const&>().clone()))>>
    : Bool<true> {};

    //! Default cloning policy
    /*! Uses clone() function if type is polymorphic and function is available; copy ctor otherwise */
    template <typename T>
    using DefaultCloner = Conditional<
                            All<std::is_polymorphic<T>, is_cloneable<T>>
                            , clone_function_cloner<T>
                            , copy_constructor_cloner<T>
                        >;

    //! A smart pointer that treats the pointee as if contained by-value
    template <typename T, typename Cloner = DefaultCloner<T>, typename Deleter = std::default_delete<T>>
    class value_ptr
    : boost::totally_ordered<value_ptr<T>,
      boost::equality_comparable<value_ptr<T>, std::nullptr_t>
    > {
    public:
        using element_type = T;
        using cloner_type = Cloner;
        using deleter_type = Deleter;
        using pointer = T*;
        using reference = T&;

        //! Constructs a null pointer
        constexpr value_ptr() noexcept : storage(nullptr, cloner_type{}, deleter_type{}) {}
        //! Constructs a null pointer
        constexpr value_ptr(std::nullptr_t) noexcept : value_ptr() {}

        //! Takes ownership of an existing pointer
        template <typename U>
        explicit value_ptr(U* ptr) noexcept
        : storage(ptr, cloner_type{}, deleter_type{}) {
            static_assert(std::is_convertible<U*, pointer>::value, "pointee type must be compatible");
            static_assert(!std::is_polymorphic<U>::value || !std::is_same<cloner_type, copy_constructor_cloner<T>>::value,
                          "conversion cannot cause slicing");
        }

        template <typename U, typename C, typename D,
                  EnableIf<std::is_convertible<U*, pointer>,
                           std::is_convertible<C, cloner_type>,
                           std::is_convertible<D, deleter_type>
                          > = _>
        value_ptr(U* ptr, C&& cloner, D&& deleter)
        : storage(ptr, std::forward<C>(cloner), std::forward<D>(deleter)) {}

        //! Makes a copy, according to the cloning policy
        value_ptr(value_ptr const& that)
        : storage(clone(that.get_ptr()), that.get_cloner(), that.get_deleter()) {}

        //! Makes a copy, according to the cloning policy
        template <typename U, typename C, typename D,
                  EnableIf<std::is_convertible<U*, pointer>> = _>
        value_ptr(value_ptr<U, C, D> const& that)
        : storage(clone(that.get_ptr()), that.get_cloner(), that.get_deleter()) {}

        //! Moves from another value_ptr
        value_ptr(value_ptr&& that) noexcept
        : storage(that.release(), std::move(that.get_cloner()), std::move(that.get_deleter())) {}

        //! Moves from another value_ptr
        template <typename U, typename C, typename D,
                  EnableIf<std::is_convertible<U*, pointer>> = _>
        value_ptr(value_ptr<U, C, D>&& that) noexcept
        : storage(that.release(), std::move(that.get_cloner()), std::move(that.get_deleter())) {}

        //! Destroys the value_ptr
        ~value_ptr() noexcept(noexcept(std::declval<value_ptr>().reset())) {
            reset();
        }

        //! Makes this pointer null
        value_ptr& operator=(std::nullptr_t) noexcept {
            reset();
            return *this;
        }

        //! Assigns another pointer to this one
        value_ptr& operator=(value_ptr that) noexcept {
            swap(that);
            return *this;
        }

        //! Dereferences the pointer
        reference operator*() const noexcept {
            return *get();
        }
        //! Forwards member access to the underlying pointer
        pointer operator->() const noexcept {
            return get();
        }
        //! Obtains the underlying pointer
        pointer get() const noexcept {
            return get_ptr();
        }

        //! Tests if the pointer is null
        explicit operator bool() const noexcept {
            return get();
        }

        //! Releases ownership of the underlying pointer
        pointer release() noexcept {
            pointer old = get_ptr();
            get_ptr() = nullptr;
            return old;
        }

        //! Resets the underlying pointer
        void reset(pointer p = {}) noexcept(noexcept(std::declval<deleter_type&>()(p))) {
            std::swap(get_ptr(), p);
            get_deleter()(p);
        }

        void swap(value_ptr& that) {
            using std::swap;
            swap(get_ptr(), that.get_ptr());
            swap(get_cloner(), that.get_cloner());
            swap(get_deleter(), that.get_deleter());
        }

        cloner_type& get_cloner() { return std::get<1>(storage); }
        cloner_type const& get_cloner() const { return std::get<1>(storage); }

        deleter_type& get_deleter() { return std::get<2>(storage); }
        deleter_type const& get_deleter() const { return std::get<2>(storage); }

    private:
        std::tuple<pointer, cloner_type, deleter_type> storage;

        pointer& get_ptr() { return std::get<0>(storage); }
        pointer const& get_ptr() const { return std::get<0>(storage); }

        template <typename Ptr>
        pointer clone(Ptr p) {
            return p? get_cloner()(p) : nullptr;
        }
    };

    template <typename T, typename Cloner, typename Deleter>
    void swap(value_ptr<T, Cloner, Deleter>& x, value_ptr<T, Cloner, Deleter>& y) {
        x.swap(y);
    }

    template <typename T, typename Cloner, typename Deleter>
    bool operator==(value_ptr<T, Cloner, Deleter> const& x, value_ptr<T, Cloner, Deleter> const& y) {
        return x.get() == y.get();
    }
    template <typename T, typename Cloner, typename Deleter>
    bool operator<(value_ptr<T, Cloner, Deleter> const& x, value_ptr<T, Cloner, Deleter> const& y) {
        return std::less<T>()(x.get(), y.get());
    }
    template <typename T, typename Cloner, typename Deleter>
    bool operator==(value_ptr<T, Cloner, Deleter> const& x, std::nullptr_t) {
        return x.get() == nullptr;
    }

    //! Factory for value_ptr
    //! Classic make_value: just arguments to forward, default cloner and deleter
    template <typename T, typename... Args,
              EnableIf<no_named_parameters<Args...>> = _,
              typename Pointer = value_ptr<T>>
    Pointer make_value(Args&&... args) {
        return Pointer { new T(std::forward<Args>(args)...) };
    }
    //! make_value from a raw pointer (like `value_ptr<T>(p)` but with deduction)
    template <typename T = deduced,
              typename Raw,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = value_ptr<Pointee>>
    Pointer make_value(names::raw_parameter<Raw> const& raw) {
        return Pointer { raw.forward() };
    }

    //! make_value with value-initialization and a custom cloner
    template <typename T, typename Cloner,
              typename Pointer = value_ptr<T, Decay<Cloner>>>
    Pointer make_value(names::cloner_parameter<Cloner> const& cloner) {
        return Pointer { new T{}, cloner.forward(), std::default_delete<T> {} };
    }

    //! make_value with value-initialization and a custom deleter
    template <typename T, typename Deleter,
              typename Pointer = value_ptr<T, DefaultCloner<T>, Decay<Deleter>>>
    Pointer make_value(names::deleter_parameter<Deleter> const& deleter) {
        return Pointer { new T{}, DefaultCloner<T> {}, deleter.forward() };
    }

    //! make_value with value-initialization, custom cloner and custom deleter
    template <typename T, typename Arg0, typename Arg1,
              EnableIf<is_named_parameter<Arg0>, is_named_parameter<Arg1>> = _,
              typename Cloner = ParameterType<GetParameter<names::cloner_name, Arg0, Arg1>>,
              typename Deleter = ParameterType<GetParameter<names::deleter_name, Arg0, Arg1>>,
              typename Pointer = value_ptr<T, Decay<Cloner>, Decay<Deleter>>>
    Pointer make_value(Arg0 const& arg0, Arg1 const& arg1) {
        return Pointer { new T{}, forward_named(names::cloner, arg0, arg1), forward_named(names::deleter, arg0, arg1) };
    }

    namespace value_detail {
        //! make_value from a tuple, with custom cloner and custom deleter (indices backend)
        template <typename T, typename Tuple, typename Cloner, typename Deleter,
                  int... Indices,
                  typename Pointer = value_ptr<T, Decay<Cloner>, Decay<Deleter>>>
        Pointer make(Tuple&& tuple, Cloner&& cloner, Deleter&& deleter, indices<Indices...>) {
            using std::get;
            return Pointer { new T(get<Indices>(tuple)...), std::forward<Cloner>(cloner), std::forward<Deleter>(deleter) };
        }
    } // namespace value_detail

    //! make_value from a tuple, with custom cloner
    template <typename T, typename Tuple, typename Cloner,
              DisableIf<is_named_parameter<Tuple>> = _,
              typename Pointer = value_ptr<T, Decay<Cloner>>>
    Pointer make_value(Tuple&& tuple, names::cloner_parameter<Cloner> const& cloner) {
        return value_detail::make<T>(std::forward<Tuple>(tuple), cloner.forward(), std::default_delete<T> {}, IndicesFor<Tuple>{});
    }
    //! make_value from a tuple, with custom deleter
    template <typename T, typename Tuple, typename Deleter,
              DisableIf<is_named_parameter<Tuple>> = _,
              typename Pointer = value_ptr<T, DefaultCloner<T>, Decay<Deleter>>>
    Pointer make_value(Tuple&& tuple, names::deleter_parameter<Deleter> const& deleter) {
        return value_detail::make<T>(std::forward<Tuple>(tuple), DefaultCloner<T> {}, deleter.forward(), IndicesFor<Tuple>{});
    }
    //! make_value from a tuple, with custom cloner and custom deleter
    template <typename T, typename Tuple, typename Arg0, typename Arg1,
              EnableIf<Not<is_named_parameter<Tuple>>, is_named_parameter<Arg0>, is_named_parameter<Arg1>> = _,
              typename Cloner = ParameterType<GetParameter<names::cloner_name, Arg0, Arg1>>,
              typename Deleter = ParameterType<GetParameter<names::deleter_name, Arg0, Arg1>>,
              typename Pointer = value_ptr<T, Decay<Cloner>, Decay<Deleter>>>
    Pointer make_value(Tuple&& tuple, Arg0 const& arg0, Arg1 const& arg1) {
        return value_detail::make<T>(std::forward<Tuple>(tuple),
                                     forward_named(names::cloner, arg0, arg1),
                                     forward_named(names::deleter, arg0, arg1),
                                     IndicesFor<Tuple>{});
    }

    //! make_value from a raw pointer, with custom cloner
    template <typename T = deduced,
              typename Arg0, typename Arg1,
              EnableIf<is_named_parameter<Arg0>,
                       is_named_parameter<Arg1>,
                       has_parameter<names::raw_name, Arg0, Arg1>,
                       has_parameter<names::cloner_name, Arg0, Arg1>> = _,
              typename Raw = GetParameterType<names::raw_name, Arg0, Arg1>,
              typename Cloner = GetParameterType<names::cloner_name, Arg0, Arg1>,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = value_ptr<Pointee, Decay<Cloner>>>
    Pointer make_value(Arg0 const& arg0, Arg1 const& arg1) {
        return Pointer { forward_named(names::raw, arg0, arg1), forward_named(names::cloner, arg0, arg1), std::default_delete<Pointee> {} };
    }
    //! make_value from a raw pointer, with custom deleter
    template <typename T = deduced,
              typename Arg0, typename Arg1,
              EnableIf<is_named_parameter<Arg0>,
                       is_named_parameter<Arg1>,
                       has_parameter<names::raw_name, Arg0, Arg1>,
                       has_parameter<names::deleter_name, Arg0, Arg1>> = _,
              typename Raw = GetParameterType<names::raw_name, Arg0, Arg1>,
              typename Deleter = GetParameterType<names::deleter_name, Arg0, Arg1>,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = value_ptr<Pointee, DefaultCloner<Pointee>, Decay<Deleter>>>
    Pointer make_value(Arg0 const& arg0, Arg1 const& arg1) {
        return Pointer { forward_named(names::raw, arg0, arg1), DefaultCloner<Pointee> {}, forward_named(names::deleter, arg0, arg1) };
    }
    //! make_value from a raw pointer, with custom cloner, with custom deleter
    template <typename T = deduced,
              typename Arg0, typename Arg1, typename Arg2,
              EnableIf<is_named_parameter<Arg0>,
                       is_named_parameter<Arg1>,
                       is_named_parameter<Arg2>,
                       has_parameter<names::raw_name, Arg0, Arg1, Arg2>,
                       has_parameter<names::cloner_name, Arg0, Arg1, Arg2>,
                       has_parameter<names::deleter_name, Arg0, Arg1, Arg2>> = _,
              typename Raw = GetParameterType<names::raw_name, Arg0, Arg1, Arg2>,
              typename Cloner = GetParameterType<names::cloner_name, Arg0, Arg1, Arg2>,
              typename Deleter = GetParameterType<names::deleter_name, Arg0, Arg1, Arg2>,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = value_ptr<Pointee, Decay<Cloner>, Decay<Deleter>>>
    Pointer make_value(Arg0 const& arg0, Arg1 const& arg1, Arg2 const& arg2) {
        return Pointer { forward_named(names::raw, arg0, arg1, arg2),
                         forward_named(names::cloner, arg0, arg1, arg2),
                         forward_named(names::deleter, arg0, arg1, arg2) };
    }

    //! Allocator-based factory for value_ptr
    template <typename T, typename A, typename... Args,
              typename Cloner = allocator_cloner<T, A>,
              typename Deleter = allocator_delete<T, A>,
              typename Pointer = value_ptr<T, Cloner, Deleter>>
    Pointer allocate_value(A const& a, Args&&... args) {
        A a2 { a };
        auto holder = allocator_detail::allocate(a2, 1);
        ::new(holder.get()) T(std::forward<Args>(args)...);
        return Pointer { holder.release(), Cloner { a }, Deleter { std::move(a2) } };
        // TODO: get the cloner and deleter to share the allocator
    }
} // namespace wheels

#endif // WHEELS_SMART_PTR_VALUE_PTR_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// make_unique helper, similar to make_shared

#ifndef WHEELS_SMART_PTR_UNIQUE_PTR_HPP
#define WHEELS_SMART_PTR_UNIQUE_PTR_HPP

#include "../allocator.h++"
#include "../meta.h++"
#include "../named_param.h++"
#include "../detail/pointer_param.h++"
#include "../tuple.h++"

#include <cstddef>
#include <functional>
#include <memory>
#include <new>
#include <tuple>
#include <utility>

namespace wheels {
    //! Factory for unique_ptr
    //! Classic make_unique: just arguments to forward, default deleter
    template <typename T, typename... Args,
              EnableIf<Not<std::is_array<T>>,
                       no_named_parameters<Args...>
                      > = _,
              typename Pointer = std::unique_ptr<T>>
    Pointer make_unique(Args&&... args) {
        return Pointer { new T(std::forward<Args>(args)...) };
    }

    //! make_unique for arrays: both T[] and T[N] supported
    template <typename T,
              EnableIf<std::is_array<T>> = _,
              typename Pointee = RemoveExtent<T>,
              std::ptrdiff_t Extent = std::extent<T>::value,
              typename Pointer = std::unique_ptr<Pointee[]>>
    Pointer make_unique(std::ptrdiff_t size = 0) {
        return Pointer { new Pointee[Extent == 0? size : Extent] };
    }
    //! make_unique from a raw pointer (like `unique_ptr<T>(p)` but with deduction)
    template <typename T = deduced,
              typename Raw,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = std::unique_ptr<Pointee>>
    Pointer make_unique(names::raw_parameter<Raw> const& raw) {
        return Pointer { raw.forward() };
    }
    //! make_unique with value-initialization and a custom deleter
    template <typename T, typename Deleter,
              typename Pointer = std::unique_ptr<T, Decay<Deleter>>>
    Pointer make_unique(names::deleter_parameter<Deleter> const& deleter) {
        return Pointer { new T{}, deleter.forward() };
    }

    namespace unique_detail {
        //! make_unique from a tuple, with custom deleter (indices backend)
        template <typename T, typename Tuple, typename Deleter,
                  int... Indices,
                  typename Pointer = std::unique_ptr<T, Decay<Deleter>>>
        Pointer make(Tuple&& tuple, Deleter&& deleter, indices<Indices...>) {
            using std::get;
            return Pointer { new T(get<Indices>(tuple)...), std::forward<Deleter>(deleter) };
        }
    } // namespace unique_detail

    //! make_unique from a tuple, with custom deleter
    template <typename T, typename Tuple, typename Deleter,
              DisableIf<is_named_parameter<Tuple>> = _,
              typename Pointer = std::unique_ptr<T, Decay<Deleter>>>
    Pointer make_unique(Tuple&& tuple, names::deleter_parameter<Deleter> const& deleter) {
        return unique_detail::make<T>(std::forward<Tuple>(tuple), deleter.forward(), IndicesFor<Tuple>{});
    }
    //! make_unique from a raw pointer, with custom deleter
    template <typename T = deduced,
              typename Arg0, typename Arg1,
              EnableIf<is_named_parameter<Arg0>,
                       is_named_parameter<Arg1>,
                       has_parameter<names::raw_name, Arg0, Arg1>,
                       has_parameter<names::deleter_name, Arg0, Arg1>
                       > = _,
              typename Raw = GetParameterType<names::raw_name, Arg0, Arg1>,
              typename Deleter = GetParameterType<names::deleter_name, Arg0, Arg1>,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = std::unique_ptr<Pointee, Decay<Deleter>>>
    Pointer make_unique(Arg0 const& arg0, Arg1 const& arg1) {
        return Pointer { forward_named(names::raw, arg0, arg1), forward_named(names::deleter, arg0, arg1) };
    }

    //! Factory for unique_ptr from an allocator
    template <typename T, typename A, typename... Args,
              typename Deleter = allocator_delete<T, A>,
              typename Pointer = std::unique_ptr<T, Deleter>>
    Pointer allocate_unique(A const& a, Args&&... args) {
        A a2 { a };
        auto holder = allocator_detail::allocate(a2, 1);
        ::new(holder.get()) T(std::forward<Args>(args)...);
        return Pointer { holder.release(), Deleter { std::move(a2) } };
    }

    //! unique_ptr with type-erased deleter
    template <typename T>
    using exclusive_ptr = std::unique_ptr<T, std::function<void(T*)>>;
} // namespace wheels

#endif // WHEELS_SMART_PTR_UNIQUE_PTR_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// make_shared factory with named parameters for the deleter

#ifndef WHEELS_SMART_PTR_SHARED_PTR_HPP
#define WHEELS_SMART_PTR_SHARED_PTR_HPP

#include "../allocator.h++"
#include "../meta.h++"
#include "../named_param.h++"
#include "../detail/pointer_param.h++"
#include "../tuple.h++"

#include <memory>

namespace wheels {
    //! Factory for shared_ptr
    //! Classic make_shared: just arguments to forward, default deleter
    template <typename T, typename... Args,
              EnableIf<no_named_parameters<Args...>> = _,
              typename Pointer = std::shared_ptr<T>>
    Pointer make_shared(Args&&... args) {
        return Pointer { new T(std::forward<Args>(args)...) };
    }

    //! make_shared from a raw pointer (like `shared_ptr<T>(p)` but with deduction)
    template <typename T = deduced,
              typename Raw,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = std::shared_ptr<Pointee>>
    Pointer make_shared(names::raw_parameter<Raw> const& raw) {
        return Pointer { raw.forward() };
    }
    //! make_shared with value-initialization and a custom deleter
    template <typename T, typename Deleter,
              typename Pointer = std::shared_ptr<T>>
    Pointer make_shared(names::deleter_parameter<Deleter> const& deleter) {
        return Pointer { new T{}, deleter.forward() };
    }

    namespace shared_detail {
        //! make_shared from a tuple, with custom deleter (indices backend)
        template <typename T, typename Tuple, typename Deleter,
                  int... I,
                  typename Pointer = std::shared_ptr<T>>
        Pointer make(Tuple&& tuple, Deleter&& deleter, indices<I...>) {
            using std::get;
            return Pointer { new T(get<I>(tuple)...), std::forward<Deleter>(deleter) };
        }
    } // namespace shared_detail

    //! make_shared from a tuple, with custom deleter
    template <typename T, typename Tuple, typename Deleter,
              DisableIf<is_named_parameter<Tuple>> = _,
              typename Pointer = std::shared_ptr<T>>
    Pointer make_shared(Tuple&& tuple, names::deleter_parameter<Deleter> const& deleter) {
        return shared_detail::make<T>(std::forward<Tuple>(tuple), deleter.forward(), IndicesFor<Tuple>{});
    }
    //! make_shared from a raw pointer, with custom deleter
    template <typename T = deduced,
              typename Arg0, typename Arg1,
              EnableIf<is_named_parameter<Arg0>,
                       is_named_parameter<Arg1>,
                       has_parameter<names::raw_name, Arg0, Arg1>,
                       has_parameter<names::deleter_name, Arg0, Arg1>
                       > = _,
              typename Raw = GetParameterType<names::raw_name, Arg0, Arg1>,
              typename Deleter = GetParameterType<names::deleter_name, Arg0, Arg1>,
              typename Pointee = Conditional<is_deduced<T>, RemovePointer<Bare<Raw>>, T>,
              typename Pointer = std::shared_ptr<Pointee>>
    Pointer make_shared(Arg0 const& arg0, Arg1 const& arg1) {
        return Pointer { forward_named(names::raw, arg0, arg1), forward_named(names::deleter, arg0, arg1) };
    }
}

#endif // WHEELS_SMART_PTR_SHARED_PTR_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Enum manipulation features

#ifndef WHEELS_ENUMS_HPP
#define WHEELS_ENUMS_HPP

#include "detail/config.h++"

#include "meta.h++"

namespace wheels {
    //! Enables the bitwise operators for an enum.
    /*! Use this trait to mark enums that are a collection of flags. */
    template <typename Enum>
    struct is_flags : Bool<false> {};

    //! Enables the arithmetic operators for an enum.
    /*! Use this trait to mark enums that are a collection of named numbers. */
    template <typename Enum>
    struct is_arithmetic : Bool<false> {};

    //! Returns the underlying value of an given enum value
    template <typename Enum>
    UnderlyingType<Enum> to_underlying(Enum e) {
        return static_cast<UnderlyingType<Enum>>(e);
    }
} // namespace wheels

#define WHEELS_ENUM_UNARY_OPERATOR(OP, KIND) \
    template <typename Enum, \
              ::wheels::EnableIf< ::std::is_enum<Enum>, ::wheels::is_##KIND<Enum>> = ::wheels::_> \
    constexpr Enum operator OP(Enum const& value) { \
        return static_cast<Enum>(OP wheels::to_underlying(value)); \
    }

#define WHEELS_ENUM_BINARY_OPERATOR(OP, KIND) \
    template <typename Enum, \
              ::wheels::EnableIf< ::std::is_enum<Enum>, ::wheels::is_##KIND<Enum>> = ::wheels::_> \
    constexpr Enum operator OP(Enum const& lhs, Enum const& rhs) { \
        return static_cast<Enum>(wheels::to_underlying(lhs) OP wheels::to_underlying(rhs)); \
    } \
    template <typename Enum, \
              ::wheels::EnableIf< ::std::is_enum<Enum>, ::wheels::is_##KIND<Enum>> = ::wheels::_> \
    Enum operator OP##=(Enum& lhs, Enum const& rhs) { \
        return lhs = lhs OP rhs; \
    }

WHEELS_ENUM_BINARY_OPERATOR(|, flags)
WHEELS_ENUM_BINARY_OPERATOR(&, flags)
WHEELS_ENUM_BINARY_OPERATOR(^, flags)
WHEELS_ENUM_UNARY_OPERATOR(~, flags)

namespace wheels {
    //! Tests if an enum value has all the given flags set
    template <typename Enum,
              EnableIf<std::is_enum<Enum>, is_flags<Enum>> = _>
    constexpr bool has_flag(Enum value, Enum flag) {
        return (value & flag) == flag;
    }
    //! Returns enum value, but with the given flags set
    template <typename Enum,
              EnableIf<std::is_enum<Enum>, is_flags<Enum>> = _>
    constexpr Enum set_flag(Enum value, Enum flag) {
        return value | flag;
    }
    //! Returns enum value, but with the given flags cleared
    template <typename Enum,
              EnableIf<std::is_enum<Enum>, is_flags<Enum>> = _>
    constexpr Enum clear_flag(Enum value, Enum flag) {
        return value & ~flag;
    }
    //! Returns enum value, but with the given flags toggled
    template <typename Enum,
              EnableIf<std::is_enum<Enum>, is_flags<Enum>> = _>
    constexpr Enum toggle_flag(Enum value, Enum flag) {
        return value ^ flag;
    }
} // namespace wheels

WHEELS_ENUM_BINARY_OPERATOR(+, arithmetic)
WHEELS_ENUM_BINARY_OPERATOR(-, arithmetic)
WHEELS_ENUM_BINARY_OPERATOR(*, arithmetic)
WHEELS_ENUM_BINARY_OPERATOR(/, arithmetic)
WHEELS_ENUM_BINARY_OPERATOR(%, arithmetic)
WHEELS_ENUM_UNARY_OPERATOR(+, arithmetic)
WHEELS_ENUM_UNARY_OPERATOR(-, arithmetic)

#undef WHEELS_ENUM_UNARY_OPERATOR
#undef WHEELS_ENUM_BINARY_OPERATOR

template <typename Enum,
          wheels::EnableIf<std::is_enum<Enum>, wheels::is_arithmetic<Enum>> = wheels::_>
Enum& operator++(Enum& value) {
    return value = static_cast<Enum>(wheels::to_underlying(value) + 1);
}

template <typename Enum,
          wheels::EnableIf<std::is_enum<Enum>, wheels::is_arithmetic<Enum>> = wheels::_>
Enum& operator--(Enum& value) {
    return value = static_cast<Enum>(wheels::to_underlying(value) - 1);
}

template <typename Enum,
          wheels::EnableIf<std::is_enum<Enum>, wheels::is_arithmetic<Enum>> = wheels::_>
Enum operator++(Enum& value, int) {
    auto temp = value;
    value = static_cast<Enum>(wheels::to_underlying(value) + 1);
    return temp;
}

template <typename Enum,
          wheels::EnableIf<std::is_enum<Enum>, wheels::is_arithmetic<Enum>> = wheels::_>
Enum operator--(Enum& value,int) {
    auto temp = value;
    value = static_cast<Enum>(wheels::to_underlying(value) - 1);
    return temp;
}

#endif // WHEELS_ENUMS_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Concept checking tools

#ifndef WHEELS_CONCEPT_HPP
#define WHEELS_CONCEPT_HPP

#include "meta.h++"

#include <boost/concept_check.hpp>
#include <boost/concept_archetype.hpp>

#include <climits>
#include <cstdint>

#include <chrono>
#include <initializer_list>
#include <istream>
#include <memory>
#include <ostream>
#include <ratio>
#include <string>

#if WHEELS_HAS_ISSUE(BROKEN_CONCEPT_CHECK)
    WHEELS_WARNING("Concept checks do not work right in this compiler");
#endif

#define WHEELS_ASSERT_TYPE(TYPE, ...) \
    static_assert(::std::is_same<decltype((__VA_ARGS__)), TYPE>::value, "Wrong type: " #__VA_ARGS__ " is not " #TYPE)

namespace wheels {
    namespace concepts {
        namespace concept_detail {
            template <typename... T>
            void ignore(T const&...);

            template <typename T>
            T rvalue();

            template <typename... Concepts>
            struct tester : Concepts... {};
        } // namespace concept_detail

        //! Concept checker
        template <typename T, template <typename...> class... Concepts>
        constexpr bool check() {
            BOOST_CONCEPT_ASSERT((concept_detail::tester<Concepts<T>...>));
            return true;
        }

        using boost::DefaultConstructible;

        using boost::EqualityComparable;
        using boost::LessThanComparable;

        using boost::InputIterator;
        using boost::OutputIterator;
        using boost::ForwardIterator;
        using boost::BidirectionalIterator;
        using boost::RandomAccessIterator;

        template <typename T>
        struct ContextuallyConvertibleToBool {
        private:
            T value;

        public:
            BOOST_CONCEPT_USAGE(ContextuallyConvertibleToBool) {
                do {} while(value);
            }
        };

        template <typename T>
        struct MoveConstructible {
            static_assert(std::is_move_constructible<T>::value, "type must be move constructible");
        };

        template <typename T>
        struct CopyConstructible : boost::CopyConstructible<T>, MoveConstructible<T> {};

        template <typename T>
        struct Destructible {
        public:
            static_assert(std::is_destructible<T>::value, "type must be destructible" );
        };

        template <typename T>
        struct MoveAssignable {
        private:
            T assigned;
            static T assignee();
            using return_type = decltype((assigned = assignee()));

        public:
            static_assert(std::is_convertible<return_type, T&>::value, "type must be move assignable" );

            BOOST_CONCEPT_USAGE(MoveAssignable) {
                assigned = assignee();
            }
        };

        template <typename T>
        struct CopyAssignable : boost::Assignable<T>, MoveAssignable<T> {};

        template <typename T>
        struct MoveSemantics : MoveConstructible<T>, MoveAssignable<T> {};

        template<typename T>
        struct CopySemantics : CopyConstructible<T>, CopyAssignable<T> {};

        template<typename T, typename Signature>
        struct Callable {
            static_assert(is_callable<T, Signature>::value, "type must be invokable for this signature");
        };

        template<typename T, typename... U>
        struct Constructible {
            static_assert(std::is_constructible<T, U...>::value, "type must be constructible from these types");
        };

        template<typename Signature>
        struct with_signature;

        template<typename Ret, typename... Args>
        struct with_signature<Ret(Args...)> {
            template<typename T>
            using Constructible = concepts::Constructible<T, Args...>;

            template<typename T>
            using Callable = concepts::Callable<T, Ret(Args...)>;
        };

        template <typename T, typename U = T>
        struct LvalueSwappable {
        public:
            BOOST_CONCEPT_USAGE(LvalueSwappable) {
                using std::swap;
                swap(t, u);
                swap(u, t);
            }
        private:
            T t;
            U u;
        };

        template <typename T, typename U = T>
        struct RvalueSwappable {
        public:
            BOOST_CONCEPT_USAGE(RvalueSwappable) {
                using std::swap;
                swap(concept_detail::rvalue<T>(), concept_detail::rvalue<U>());
                swap(concept_detail::rvalue<U>(), concept_detail::rvalue<T>());
            }
        };

        template <typename T, typename U = T>
        struct Swappable : LvalueSwappable<T, U>
                         , RvalueSwappable<T, U> {};

        template <typename T, typename U = T>
        struct ValueSwappable : Swappable<decltype(*std::declval<T&>())>
                              , Swappable<decltype(*std::declval<T&&>())> {};

        template <typename P>
        struct NullablePointer : EqualityComparable<P>
                               , DefaultConstructible<P>
                               , CopySemantics<P>
                               , Destructible<P>
                               , LvalueSwappable<P> {
        public:
            BOOST_CONCEPT_USAGE(NullablePointer) {
                std::nullptr_t const npc = nullptr;
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<P>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a != b)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac != b)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a != bc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac != bc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a == np)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac == np)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a == npc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac == npc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(np == a)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(npc == a)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(np == bc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(npc == bc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a != np)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac != np)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(a != npc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(ac != npc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(np != a)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(npc != a)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(np != bc)>));
                BOOST_CONCEPT_ASSERT((ContextuallyConvertibleToBool<decltype(npc != bc)>));
                P u(np);
                P uc(npc);
                WHEELS_ASSERT_TYPE(P&, t = np);
                WHEELS_ASSERT_TYPE(P&, t = npc);

                concept_detail::ignore(u, uc);
            }
        private:
            P t;
            P a, b;
            P const ac, bc;
            std::nullptr_t np;
        };

        template <typename H, typename K>
        struct Hash : CopyConstructible<H>, Destructible<H> {
        private:
            struct U { operator K const(); };

        public:
            static_assert(is_function_object<H, std::size_t(K)>::value, "H must be a function object type");
            static_assert(is_function_object<H, std::size_t(U)>::value, "H must be a function object type");

            BOOST_CONCEPT_USAGE(Hash) {
                WHEELS_ASSERT_TYPE(std::size_t, h(k));
                WHEELS_ASSERT_TYPE(std::size_t, h(u));
            }
        private:
            H h;
            K k;
            U u;
        };

        template <typename K>
        struct for_key {
            template <typename T>
            using Hash = concepts::Hash<T, K>;
        };

        template <typename X>
        struct Allocator {
        public:
            using XX = std::allocator_traits<X>;
            using T = typename X::value_type;
            using pointer = typename XX::pointer;
            using const_pointer = typename XX::const_pointer;
            using void_pointer = typename XX::void_pointer;
            using const_void_pointer = typename XX::const_void_pointer;
            using size_type = typename XX::size_type;
            using difference_type = typename XX::difference_type;

            static_assert(std::is_convertible<pointer,const_pointer>::value,
                          "X::pointer must be convertible to X::const_pointer");
            static_assert(std::is_convertible<pointer,void_pointer>::value,
                          "X::pointer must be convertible to X::void_pointer");
            static_assert(std::is_convertible<pointer,const_void_pointer>::value,
                          "X::pointer must be convertible to X::const_void_pointer");
            static_assert(std::is_convertible<const_pointer,const_void_pointer>::value,
                          "X::const_pointer must be convertible to X::const_void_pointer");
            static_assert(std::is_convertible<void_pointer,const_void_pointer>::value,
                          "X::void_pointer must be convertible to X::const_void_pointer");
            static_assert(std::is_unsigned<size_type>::value && std::is_integral<size_type>::value,
                          "X::size_type must be an unsigned integer type");
            static_assert(std::is_unsigned<size_type>::value && std::is_integral<size_type>::value,
                          "X::size_type must be an unsigned integer type");
            static_assert(std::is_signed<difference_type>::value && std::is_integral<difference_type>::value,
                          "X::difference_type must be an signed integer type");
            static_assert(std::is_class<X>::value, "Allocators must be of class type");

            struct C { C(int x, int y, int z); };
            BOOST_CONCEPT_USAGE(Allocator) {
                BOOST_CONCEPT_ASSERT((NullablePointer<pointer>));
                BOOST_CONCEPT_ASSERT((NullablePointer<const_pointer>));
                BOOST_CONCEPT_ASSERT((NullablePointer<void_pointer>));
                BOOST_CONCEPT_ASSERT((NullablePointer<const_void_pointer>));
                T* x;
                WHEELS_ASSERT_TYPE(T&, *p);
                WHEELS_ASSERT_TYPE(T const&, *q);
                WHEELS_ASSERT_TYPE(pointer, static_cast<pointer>(w));
                WHEELS_ASSERT_TYPE(const_pointer, static_cast<const_pointer>(z));
                WHEELS_ASSERT_TYPE(pointer, a.allocate(n));
                WHEELS_ASSERT_TYPE(pointer, XX::allocate(a, n, u));
                a.deallocate(p, n);
                WHEELS_ASSERT_TYPE(size_type, XX::max_size(a));
                WHEELS_ASSERT_TYPE(bool, a1 == a2);
                WHEELS_ASSERT_TYPE(bool, a1 != a2);
                X aa1(a);
                X aa2(std::move(a));
                XX::construct(a, c, 17, 23, 42);
                XX::destroy(a, c);
                WHEELS_ASSERT_TYPE(X, XX::select_on_container_copy_construction(a));
                bool pocca = XX::propagate_on_container_copy_assignment::value;
                bool pocma = XX::propagate_on_container_move_assignment::value;
                bool pocs = XX::propagate_on_container_swap::value;

                concept_detail::ignore(x, aa1, aa2, pocca, pocs, pocma);
            }
        private:
            X& a;
            X& a1;
            X& a2;
            pointer p;
            const_pointer q;
            void_pointer w;
            const_void_pointer z;
            size_type n;
            const_pointer u;
            C* c;
        };

        namespace concept_detail {
            struct numeric_assign_byref_tester {
                template <typename T, T& (T::*)(T const&) = &T::operator= > class assignment {};

                template <typename T>
                static Bool<true> test(assignment<T>*);
                template <typename>
                static Bool<false> test(...);
            };
            struct numeric_assign_byval_tester {
                template <typename T, T& (T::*)(T) = &T::operator= > class assignment {};

                template <typename T>
                static Bool<true> test(assignment<T>*);
                template <typename>
                static Bool<false> test(...);
            };
            template <typename T>
            struct has_numeric_assign : Any<decltype(numeric_assign_byref_tester::test<T>(nullptr)),
                                            decltype(numeric_assign_byval_tester::test<T>(nullptr))> {};

            template <typename T>
            void operator&(T) = delete;

            template <typename T, typename = void>
            struct has_overloaded_addressof : Bool<false> {};
            template <typename T>
            struct has_overloaded_addressof<T, Void<decltype(std::declval<T>().operator&())>>
            : Bool<true> {};
            template <typename T>
            struct has_overloaded_addressof<T, Void<decltype(operator&(std::declval<T>()))>>
            : Bool<true> {};
        } // namespace concept_detail

        template <typename N>
        struct Numeric {
        public:
            static_assert(!std::is_abstract<N>::value,
                          "N cannot be an abstract class");
            static_assert(!std::is_reference<N>::value,
                          "N cannot be a reference type");
            static_assert(!std::is_const<N>::value && !std::is_volatile<N>::value,
                          "N cannot be cv-qualified");
            static_assert(!std::is_class<N>::value || std::is_default_constructible<N>::value,
                          "if N is a class is must have a public default constructor");
            static_assert(!std::is_class<N>::value || std::is_constructible<N, N const&>::value,
                          "if N is a class is must have a public copy constructor");
            static_assert(!std::is_class<N>::value || std::is_destructible<N>::value,
                          "if N is a class is must have a public destructor");
            static_assert(!std::is_class<N>::value || concept_detail::has_numeric_assign<N>::value,
                          "if N is a class is must have a public assignment operator with signature N& N::operator=(N const&) or N& N::operator=(N)");
            static_assert(!std::is_class<N>::value || !concept_detail::has_overloaded_addressof<N>::value,
                          "if N is a class is must not overload unary operator&");
        };

        namespace concept_detail {
            template <typename T>
            struct is_ratio : Bool<false> {};
            template <std::intmax_t Num, std::intmax_t Den>
            struct is_ratio<std::ratio<Num, Den>> : Bool<true> {};
        } // namespace concept_detail

        template <typename C>
        struct Clock {
        public:
            using rep = typename C::rep;
            using period = typename C::period;
            using duration = typename C::duration;
            using time_point = typename C::time_point;

            static_assert(std::is_same<duration,std::chrono::duration<rep,period>>::value,
                          "C::duration must be std::chrono::duration<C::rep, C::period>");
            static_assert(concept_detail::is_ratio<period>::value,
                          "C::period must be a specialization of std::ratio");

            BOOST_CONCEPT_USAGE(Clock) {
                WHEELS_ASSERT_TYPE(bool const, C::is_steady);
                WHEELS_ASSERT_TYPE(time_point, C::now());
            }
        };

        template <typename TC>
        struct TrivialClock : Clock<TC> {
        public:
            using rep = typename Clock<TC>::rep;
            using period = typename Clock<TC>::period;
            using duration = typename Clock<TC>::duration;
            using time_point = typename Clock<TC>::time_point;

            static_assert(noexcept(TC::now()), "TC::now() cannot throw exceptions");

            BOOST_CONCEPT_USAGE(TrivialClock) {
                BOOST_CONCEPT_ASSERT((EqualityComparable<rep>));
                BOOST_CONCEPT_ASSERT((LessThanComparable<rep>));
                BOOST_CONCEPT_ASSERT((DefaultConstructible<rep>));
                BOOST_CONCEPT_ASSERT((CopyConstructible<rep>));
                BOOST_CONCEPT_ASSERT((CopyAssignable<rep>));
                BOOST_CONCEPT_ASSERT((Destructible<rep>));
                BOOST_CONCEPT_ASSERT((Numeric<rep>));
                BOOST_CONCEPT_ASSERT((LvalueSwappable<rep>));

                BOOST_CONCEPT_ASSERT((EqualityComparable<duration>));
                BOOST_CONCEPT_ASSERT((LessThanComparable<duration>));
                BOOST_CONCEPT_ASSERT((DefaultConstructible<duration>));
                BOOST_CONCEPT_ASSERT((CopyConstructible<duration>));
                BOOST_CONCEPT_ASSERT((CopyAssignable<duration>));
                BOOST_CONCEPT_ASSERT((Destructible<duration>));
                BOOST_CONCEPT_ASSERT((Numeric<duration>));
                BOOST_CONCEPT_ASSERT((LvalueSwappable<duration>));

                BOOST_CONCEPT_ASSERT((EqualityComparable<time_point>));
                BOOST_CONCEPT_ASSERT((LessThanComparable<time_point>));
                BOOST_CONCEPT_ASSERT((DefaultConstructible<time_point>));
                BOOST_CONCEPT_ASSERT((CopyConstructible<time_point>));
                BOOST_CONCEPT_ASSERT((CopyAssignable<time_point>));
                BOOST_CONCEPT_ASSERT((Destructible<time_point>));
                BOOST_CONCEPT_ASSERT((Numeric<time_point>));
                BOOST_CONCEPT_ASSERT((LvalueSwappable<time_point>));

                BOOST_CONCEPT_ASSERT((TrivialClock<typename time_point::clock>));
            }
        };

        template <typename T>
        struct CharTraits {
        public:
            using char_type = typename T::char_type;
            using int_type = typename T::int_type;
            using off_type = typename T::off_type;
            using pos_type = typename T::pos_type;
            using state_type = typename T::state_type;

            BOOST_CONCEPT_USAGE(CharTraits) {
                BOOST_CONCEPT_ASSERT((CopySemantics<state_type>));
                BOOST_CONCEPT_ASSERT((DefaultConstructible<state_type>));

                WHEELS_ASSERT_TYPE(bool, T::eq(c, d));
                static_assert(noexcept(T::eq(c, d)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(bool, T::lt(c, d));
                static_assert(noexcept(T::lt(c, d)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(int, T::compare(p, q, n));
                // TODO: Why the heck doesn't GCC noexcept all of these?
                //static_assert(noexcept(T::compare(p, q, n)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(std::size_t, T::length(p));
                //static_assert(noexcept(T::length(p)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(char_type const*, T::find(p, n, c));
                //static_assert(noexcept(T::find(p, n, c)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(char_type*, T::move(s, p, n));
                //static_assert(noexcept(T::move(s, p, n)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(char_type*, T::copy(s, p, n));
                //static_assert(noexcept(T::copy(s, p, n)), "Operations on CharTraits must not throw exceptions");
                static_assert(noexcept(T::assign(r, d)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(char_type*, T::assign(s, n, c));
                //static_assert(noexcept(T::assign(s, n, c)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(int_type, T::not_eof(e));
                static_assert(noexcept(T::not_eof(e)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(char_type, T::to_char_type(e));
                static_assert(noexcept(T::to_char_type(e)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(int_type, T::to_int_type(c));
                static_assert(noexcept(T::to_int_type(c)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(bool, T::eq_int_type(e, f));
                static_assert(noexcept(T::eq_int_type(e, f)), "Operations on CharTraits must not throw exceptions");
                WHEELS_ASSERT_TYPE(int_type, T::eof());
                static_assert(noexcept(T::eof()), "Operations on CharTraits must not throw exceptions");
            }

        private:
            char_type c, d;
            char_type const *p, *q;
            char_type* s;
            std::size_t i, j, n;
            int_type e, f;
            pos_type pos;
            state_type state;
            char_type r;
        };

        // TODO: containers

        template <typename S>
        struct SeedSequence {
        public:
            using result_type = typename S::result_type;

            static_assert(std::is_unsigned<result_type>::value && std::is_integral<result_type>::value && sizeof(result_type) * CHAR_BIT >= 32,
                          "result_type must be an unsigned integer type of at least 32 bits");

            BOOST_CONCEPT_USAGE(SeedSequence) {
                S();
                S(ib, ie);
                S(il);
                WHEELS_ASSERT_TYPE(void, q.generate(rb, re));
                WHEELS_ASSERT_TYPE(std::size_t, r.size());
                WHEELS_ASSERT_TYPE(void, r.param(ob));
            }

        private:
            S q;
            S const r;
            boost::input_iterator_archetype<std::uint32_t> ib, ie;
            boost::mutable_random_access_iterator_archetype<std::uint32_t> rb, re;
            boost::output_iterator_archetype<std::uint32_t> ob;
            std::initializer_list<result_type> il;
        };

        struct seed_sequence_archetype {
            using result_type = std::uint32_t;

            seed_sequence_archetype() {}
            template <typename It>
            seed_sequence_archetype(It, It) {}
            seed_sequence_archetype(std::initializer_list<result_type>) {}
            template <typename It>
            void generate(It, It) {}
            std::size_t size() const { return 0; }
            template <typename It>
            void param(It) {}
        };

        template <typename G>
        struct UniformRandomNumberGenerator {
        public:
            using result_type = typename G::result_type;

            static_assert(std::is_unsigned<result_type>::value && std::is_integral<result_type>::value,
                          "result_type must be an unsigned integer type");

            BOOST_CONCEPT_USAGE(UniformRandomNumberGenerator) {
                WHEELS_ASSERT_TYPE(result_type, g());
                WHEELS_ASSERT_TYPE(result_type, G::min());
                WHEELS_ASSERT_TYPE(result_type, G::max());
                static_assert(G::min() < G::max(), "G::min() must be less than G::max()");
            }

        private:
            G g;
        };

        struct uniform_random_number_generator_archetype {
            using result_type = unsigned long long;
            result_type operator()() { return 0; }
            static constexpr result_type min() { return 0; }
            static constexpr result_type max() { return 42; }
        };

        template <typename E>
        struct RandomNumberEngine : UniformRandomNumberGenerator<E>
                                  , CopySemantics<E> {
        public:
            using result_type = typename E::result_type;

            BOOST_CONCEPT_USAGE(RandomNumberEngine) {
                E();
                E(x);
                E(s);
                E(q);
                WHEELS_ASSERT_TYPE(void, e.seed());
                WHEELS_ASSERT_TYPE(void, e.seed(s));
                WHEELS_ASSERT_TYPE(void, e.seed(q));
                WHEELS_ASSERT_TYPE(result_type, e());
                WHEELS_ASSERT_TYPE(void, e.discard(z));
                WHEELS_ASSERT_TYPE(bool, x == y);
                WHEELS_ASSERT_TYPE(bool, x != y);
                WHEELS_ASSERT_TYPE(bool, x != y);
                WHEELS_ASSERT_TYPE(decltype(os)&, os << x);
                WHEELS_ASSERT_TYPE(decltype(is)&, is >> v);
            }

        private:
            E e, v;
            E const x, y;
            result_type s;
            seed_sequence_archetype q;
            unsigned long long z;
            std::ostream os;
            std::istream is;
        };

        template <typename D>
        struct RandomNumberDistribution : CopySemantics<D> {
        public:
            using result_type = typename D::result_type;
            using param_type = typename D::param_type;

            static_assert(is_function_object<D, result_type(uniform_random_number_generator_archetype)>::value,
                          "a distribution must be a function object");
            static_assert(std::is_arithmetic<result_type>::value,
                          "result_type must be an arithmetic type");
            static_assert(std::is_same<typename param_type::distribution_type, D>::value,
                          "param_type::distribution_type must be this distribution type");

            BOOST_CONCEPT_USAGE(RandomNumberDistribution) {
                BOOST_CONCEPT_ASSERT((CopySemantics<param_type>));
                BOOST_CONCEPT_ASSERT((EqualityComparable<param_type>));

                D();
                D(p);
                WHEELS_ASSERT_TYPE(void, d.reset());
                WHEELS_ASSERT_TYPE(param_type, x.param());
                WHEELS_ASSERT_TYPE(void, x.param(p));
                WHEELS_ASSERT_TYPE(result_type, d(g));
                WHEELS_ASSERT_TYPE(result_type, d(g, p));
                WHEELS_ASSERT_TYPE(result_type, x.min());
                WHEELS_ASSERT_TYPE(result_type, x.max());
                WHEELS_ASSERT_TYPE(bool, x == y);
                WHEELS_ASSERT_TYPE(bool, x != y);
                WHEELS_ASSERT_TYPE(decltype(os)&, os << x);
                WHEELS_ASSERT_TYPE(decltype(is)&, is >> d);
            }

        private:
            D d;
            D const x, y;
            param_type const p;
            uniform_random_number_generator_archetype g, g1, g2;
            std::ostream os;
            std::istream is;
        };

        template <typename T>
        struct RegexTraits {
        public:
            using char_type = typename T::char_type;
            using string_type = typename T::string_type;
            using locale_type = typename T::locale_type;
            using char_class_type = typename T::char_class_type;

            static_assert(std::is_same<string_type, std::basic_string<char_type>>::value, "string_type must be std::basic_string<char_type>");
            static_assert(std::is_copy_constructible<locale_type>::value, "locale_type must be copy constructible");

            BOOST_CONCEPT_USAGE(RegexTraits) {
                WHEELS_ASSERT_TYPE(std::size_t, T::length(p));
                WHEELS_ASSERT_TYPE(char_type, v.translate(c));
                WHEELS_ASSERT_TYPE(char_type, v.translate_nocase(c));
                WHEELS_ASSERT_TYPE(string_type, v.transform(F1, F2));
                WHEELS_ASSERT_TYPE(string_type, v.transform_primary(F1, F2));
                WHEELS_ASSERT_TYPE(string_type, v.lookup_collatename(F1, F2));
                WHEELS_ASSERT_TYPE(char_class_type, v.lookup_classname(F1, F2, b));
                WHEELS_ASSERT_TYPE(bool, v.isctype(c, cl));
                WHEELS_ASSERT_TYPE(int, v.value(c, I));
                WHEELS_ASSERT_TYPE(locale_type, u.imbue(loc));
                WHEELS_ASSERT_TYPE(locale_type, v.getloc());
            }

        private:
            T u;
            T const v;
            char_type const* p;
            boost::input_iterator_archetype<std::uint32_t> I1, I2;
            boost::forward_iterator_archetype<std::uint32_t> F1, F2;
            char_type const c;
            string_type s;
            string_type const cs;
            bool b;
            int I;
            char_class_type cl;
            locale_type loc;
        };

        template <typename L>
        struct BasicLockable {
        public:
            BOOST_CONCEPT_USAGE(BasicLockable) {
                m.lock();
                m.unlock();
                static_assert(noexcept(m.unlock()), "unlock() must not throw exceptions");
            }

        private:
            L m;
        };

        template <typename L>
        struct Lockable : BasicLockable<L> {
        public:
            BOOST_CONCEPT_USAGE(Lockable) {
                WHEELS_ASSERT_TYPE(bool, m.try_lock());
            }

        private:
            L m;
        };

        template <typename L>
        struct TimedLockable : Lockable<L> {
        public:
            BOOST_CONCEPT_USAGE(TimedLockable) {
                WHEELS_ASSERT_TYPE(bool, m.try_lock_for(rel_time));
                WHEELS_ASSERT_TYPE(bool, m.try_lock_until(abs_time));
            }

        private:
            L m;
            std::chrono::nanoseconds rel_time;
            std::chrono::system_clock::time_point abs_time;
        };

        template <typename M>
        struct Mutex : Lockable<M>
                     , DefaultConstructible<M>
                     , Destructible<M> {
        public:
            BOOST_CONCEPT_USAGE(Mutex) {
                static_assert(!std::is_copy_constructible<M>::value && !std::is_move_constructible<M>::value
                           && !std::is_copy_assignable<M>::value && !std::is_move_assignable<M>::value,
                              "Mutex types shall not be copyable or movable");
            }

        private:
            M m;
        };
    } // namespace concepts
} // namespace wheels

#undef WHEELS_ASSERT_TYPE

#endif // WHEELS_CONCEPT_HPP
 
// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// std::chrono utilities

#ifndef WHEELS_CHRONO_HPP
#define WHEELS_CHRONO_HPP

#include "meta.h++"

#include <chrono>

namespace wheels {
    //! Makes a duration type with the same period but a fractional representation
    template <typename Duration>
    using FractionalDuration = std::chrono::duration<long double, typename Duration::period>;

#define WHEELS_DURATION_CONVERSION(UNIT) \
    template <template <typename> class Modifier = ::wheels::Identity, typename Duration> \
    typename Modifier< ::std::chrono::UNIT>::rep to_##UNIT(Duration d) { \
        return ::std::chrono::duration_cast<Modifier< ::std::chrono::UNIT>>(d).count(); \
    } \
    WHEELS_EXPECT_SEMICOLON

    WHEELS_DURATION_CONVERSION(nanoseconds);
    WHEELS_DURATION_CONVERSION(microseconds);
    WHEELS_DURATION_CONVERSION(milliseconds);
    WHEELS_DURATION_CONVERSION(seconds);
    WHEELS_DURATION_CONVERSION(minutes);
    WHEELS_DURATION_CONVERSION(hours);

#undef WHEELS_DURATION_CONVERSION

    namespace literal {
        namespace chrono {
#if WHEELS_HAS_ISSUE(DURATION_NO_CONSTEXPR)
    #define WHEELS_DURATION_CONSTEXPR inline
#else
    #define WHEELS_DURATION_CONSTEXPR constexpr
#endif
#define WHEELS_DURATION_LITERAL(ID, TYPE) \
            WHEELS_DURATION_CONSTEXPR ::std::chrono::TYPE operator"" _##ID(unsigned long long value) { \
                return ::std::chrono::TYPE(value); \
            } \
            WHEELS_DURATION_CONSTEXPR ::wheels::FractionalDuration< ::std::chrono::TYPE> operator"" _##ID(long double value) { \
                return ::wheels::FractionalDuration< ::std::chrono::TYPE>(value); \
            } \
            WHEELS_EXPECT_SEMICOLON

            WHEELS_DURATION_LITERAL(ns, nanoseconds);
            WHEELS_DURATION_LITERAL(mus, microseconds);
            WHEELS_DURATION_LITERAL(ms, milliseconds);
            WHEELS_DURATION_LITERAL(s, seconds);
            WHEELS_DURATION_LITERAL(min, minutes);
            WHEELS_DURATION_LITERAL(hr, hours);

#undef WHEELS_DURATION_CONSTEXPR
#undef WHEELS_DURATION_LITERAL
        } // namespace chrono
    } // namespace literal
} // namespace wheels

#endif // WHEELS_CHRONO_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Timing facilities

#ifndef WHEELS_STOPWATCH_HPP
#define WHEELS_STOPWATCH_HPP

#include <cassert>

#include <chrono>
#include <utility>

namespace wheels {
    //! A class for measuring time
    template <typename Clock>
    class basic_stopwatch {
    public:
        using rep = typename Clock::rep;
        using period = typename Clock::period;
        using duration = typename Clock::duration;
        using time_point = typename Clock::time_point;

        //! Creates a new stopwatch
        /*! Postcondition: is_running() == false && elapsed == duration::zero() */
        basic_stopwatch() = default;

        //! Starts or resumes measuring time
        /*! Precondition: is_running() == false
         *! Postcondition: is_running() == true
         */
        void start() {
            assert(!running);
            running = true;
            p = Clock::now();
            last_lap = p;
        }
        //! Stops measuring time
        /*! Precondition: is_running() == true
         *! Postcondition: is_running() == false
         */
        void stop() {
            assert(running);
            d += Clock::now() - p;
            running = false;
        }

        //! Tests if the stopwatch is currently measuring time
        /*! Returns: true if the stopwatch is measuring time; false otherwise */
        bool is_running() const {
            return running;
        }

        //! Restarts the measurement
        /*! Precondition: is_running() == true
         *! Postcondition: is_running() == true && elapsed() == duration::zero()
         */
        void restart() {
            assert(running);
            reset();
            start();
        }
        //! Resets the stopwatch
        /*! Postcondition: is_running() == false && elapsed() == duration::zero() */
        void reset() {
            d = std::chrono::duration_values<duration>::zero();
            running = false;
        }

        //! Obtains the current measurement
        /*! Returns: the total time elapsed during the current (if running) or last measurement (if not running) */
        duration elapsed() const {
            if(running) return d + Clock::now() - p;
            else return d;
        }
        //! Obtains the lap time
        /*! Returns: the total time elapsed since the last call to lap()
         *!          or since the start of the measurement if it is the first call to lap() since the start
         */
        duration lap() {
            assert(running);
            auto new_lap = Clock::now();
            auto lap_time = new_lap - last_lap;
            last_lap = new_lap;
            return lap_time;
        }

        //! Creates and starts a new stopwatch
        /*! Returns: a new stopwatch with is_running() == true
         */
        static basic_stopwatch start_new() {
            basic_stopwatch sw;
            sw.start();
            return sw;
        }

    private:
        time_point p {};
        time_point last_lap {};
        duration d = std::chrono::duration_values<duration>::zero();
        bool running = false;
    };

    //! A stopwatch with the high-resolution clock
    using stopwatch = basic_stopwatch<std::chrono::high_resolution_clock>;

    //! Execution of a function and measures the elapsed time
    /*! Returns: the total time elapsed in running fun */
    template <typename Clock = std::chrono::high_resolution_clock, typename Fun>
    typename basic_stopwatch<Clock>::duration time_execution(Fun&& fun) {
        basic_stopwatch<Clock> sw;

        sw.start();
        std::forward<Fun>(fun)();
        sw.stop();

        return sw.elapsed();
    }
} // namespace wheels

#endif // WHEELS_STOPWATCH_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Tuple utilities

#ifndef WHEELS_TUPLE_HPP
#define WHEELS_TUPLE_HPP

#include "meta.h++"

#include <cstddef>
#include <initializer_list>
#include <tuple>
#include <utility>

namespace wheels {
    // TODO: use a simple typelist instead of std::tuple for tag dispatching?

    //! Pack of indices
    template <int... Indices>
    struct indices {
        using next = indices<Indices..., sizeof...(Indices)>;
    };

    //! Indices pack construction
    template <int Size>
    struct build_indices : identity<typename build_indices<Size-1>::type::next> {};
    template <>
    struct build_indices<0> : identity<indices<>> {};
    template <int Size>
    using BuildIndices = Invoke<build_indices<Size>>;

    //! Indices pack for a given tuple
    template <typename Tuple>
    using IndicesFor = BuildIndices<std::tuple_size<Bare<Tuple>>::value>;

    template <std::size_t I, typename T>
    using TupleElement = Invoke<std::tuple_element<I, T>>;

    template <typename T>
    using TupleSize = std::tuple_size<Bare<T>>;

#if defined(WHEELS_STD_TUPLE_LAYOUT_OPTIMAL) || defined(WHEELS_STD_TUPLE_LAYOUT_UNKNOWN)

    template <typename... T>
    using tuple = std::tuple<T...>;
    using std::make_tuple;
    using std::forward_as_tuple;
    using std::tie;
    using std::tuple_cat;
    using std::get;

#else
    template <typename... T>
    struct tuple;

    namespace tuple_detail {
        template <typename T, typename Tuple>
        struct cons_tuple;
        template <typename Head, typename... Tail>
        struct cons_tuple<Head, std::tuple<Tail...>> : identity<std::tuple<Head, Tail...>> {};
        template <typename T, typename Tuple>
        using ConsTuple = typename cons_tuple<T, Tuple>::type;

        template <typename T>
        struct member { T _; }; // need this to get "alignment of a reference"
        template <typename T, typename U>
        struct layout_compare_impl : Bool<
            std::is_empty<T>::value
            || (!std::is_empty<U>::value && alignof(member<T>) > alignof(member<U>))
        > {};
        template <typename T, typename U>
        struct layout_compare
    #if defined(WHEELS_STD_TUPLE_LAYOUT_STRAIGHT)
        : layout_compare_impl<T,U> {};
    #elif defined(WHEELS_STD_TUPLE_LAYOUT_REVERSED)
        : layout_compare_impl<U,T> {};
    #endif

        template <template <typename...> class Template, typename... T>
        struct apply_invoke : identity<Template<Invoke<T>...>> {};

        template <typename T, std::size_t I>
        struct indexed : identity<indexed<T,I>> {
            using t = T;
            static constexpr std::size_t i = I;
        };

        template <typename T, typename Tuple>
        struct insert_sorted
        : identity<std::tuple<T>> {};
        template <typename T, std::size_t I, typename THead, std::size_t IHead, typename... TTail, std::size_t... ITail>
        struct insert_sorted<indexed<T, I>, std::tuple<indexed<THead, IHead>, indexed<TTail, ITail>...>>
        : Conditional<
            layout_compare<T, THead>,
            identity<std::tuple<indexed<T, I>, indexed<THead, IHead>, indexed<TTail, ITail>...>>,
            apply_invoke<ConsTuple, indexed<THead, IHead>, insert_sorted<indexed<T, I>, std::tuple<indexed<TTail, ITail>...>>>
        > {};
        template <typename T, typename Tuple>
        using InsertSorted = Invoke<insert_sorted<T, Tuple>>;

        template <typename Acc, typename... T>
        struct with_indices_impl : identity<Acc> {};
        template <typename... Acc, typename Head, typename... Tail>
        struct with_indices_impl<std::tuple<Acc...>, Head, Tail...> : with_indices_impl<std::tuple<Acc..., indexed<Head, sizeof...(Acc)>>, Tail...> {};
        template <typename... T>
        struct with_indices : with_indices_impl<std::tuple<>, T...> {};
        template <typename... T>
        using WithIndices = Invoke<with_indices<T...>>;
         
        template <std::size_t Target, typename Tuple>
        struct find_index;
        template <std::size_t Target, typename THead, std::size_t From, std::size_t To, typename... Tail>
        struct find_index<Target, std::tuple<indexed<indexed<THead, To>,From>, Tail...>>
        : Conditional<
            Bool<Target == To>,
            std::integral_constant<std::size_t, From>,
            find_index<Target, std::tuple<Tail...>>
        > {};

        template <typename Tuple>
        struct reverse_layout_impl;
        template <typename... T, std::size_t... From, std::size_t... To>
        struct reverse_layout_impl<std::tuple<indexed<indexed<T,To>,From>...>>
        : identity<std::tuple<
            indexed<T, find_index<From, std::tuple<indexed<indexed<T,To>,From>...>>::value>...
        >> {};
        template <typename Tuple>
        struct reverse_layout;
        template <typename... T>
        struct reverse_layout<std::tuple<T...>> : reverse_layout_impl<WithIndices<T...>> {};
        template <typename Tuple>
        using ReverseLayout = Invoke<reverse_layout<Tuple>>;

        template <typename Tuple>
        struct split_impl;
        template <typename... T, std::size_t... I>
        struct split_impl<std::tuple<indexed<T, I>...>> {
            using tuple = std::tuple<T...>;
            using map = std::tuple<std::integral_constant<std::size_t, I>...>;
        };
        template <typename Tuple>
        struct split {
            using tuple = typename split_impl<Tuple>::tuple;
            using map = typename split_impl<Tuple>::map;
            using inverse_map = typename split_impl<ReverseLayout<Tuple>>::map;
        };

        template <typename Acc, typename T>
        struct optimal_layout_impl : split<Acc> {};
         
        template <typename Acc, typename Head, typename... Tail>
        struct optimal_layout_impl<Acc, std::tuple<Head, Tail...>>
        : optimal_layout_impl<InsertSorted<Head, Acc>, std::tuple<Tail...>> {};

        template <typename... T>
        struct optimal_layout : optimal_layout_impl<std::tuple<>, WithIndices<T...>> {};

        template <typename... T>
        using OptimalLayoutTuple = typename optimal_layout<T...>::tuple;
        template <typename... T>
        using OptimalLayoutMap = typename optimal_layout<T...>::map;
        template <typename... T>
        using OptimalLayoutInverseMap = typename optimal_layout<T...>::inverse_map;

        template <typename Acc, typename From, typename To>
        struct convert_layout_map_impl : identity<Acc> {};
        template <typename... Acc, typename From, typename THead, typename... TTail>
        struct convert_layout_map_impl<std::tuple<Acc...>, From, std::tuple<THead, TTail...>>
        : convert_layout_map_impl<std::tuple<Acc..., TupleElement<THead::value, From>>, From, std::tuple<TTail...>> {};
        template <typename From, typename To>
        struct convert_layout_map : convert_layout_map_impl<std::tuple<>, From, To> {};
        template <typename From, typename To>
        using ConvertLayoutMap = Invoke<convert_layout_map<From, To>>;

        template <typename... T, typename... Indices>
        std::tuple<TupleElement<Indices::value, std::tuple<T...>>...> forward_mapped_tuple(std::tuple<Indices...>, std::tuple<T...> t) {
            return std::forward_as_tuple(std::forward<TupleElement<Indices::value, std::tuple<T...>>>(std::get<Indices::value>(t))...);
        }

        template <typename... T, typename... Indices>
        std::tuple<TupleElement<Indices::value, std::tuple<T...>>...> forward_mapped(std::tuple<Indices...> i, T&&... t) {
            return forward_mapped_tuple(i, std::forward_as_tuple(std::forward<T>(t)...));
        }

        template <typename... N>
        struct sum : std::integral_constant<std::size_t, 0> {};
        template <typename Head, typename... Tail>
        struct sum<Head, Tail...> : std::integral_constant<std::size_t, Head::value + sum<Tail...>::value> {};

        template <std::size_t X, std::size_t Y>
        struct position : identity<position<X, Y>> {
            static constexpr std::size_t x = X;
            static constexpr std::size_t y = Y;
        };
        template <std::size_t I, std::size_t X, std::size_t Acc, typename... Tuples>
        struct position_of_impl;
        template <std::size_t I, std::size_t X, std::size_t Acc, typename Head, typename... Tail>
        struct position_of_impl<I, X, Acc, Head, Tail...>
        : Conditional<
            Bool<(std::tuple_size<Bare<Head>>::value + Acc > I)>,
            position<X, I - Acc>,
            position_of_impl<I, X+1, Acc + std::tuple_size<Bare<Head>>::value, Tail...>
        > {};
        template <std::size_t I, typename... Tuples>
        struct position_of : position_of_impl<I, 0, 0, Tuples...> {};
        template <std::size_t I, typename... Tuples>
        using PositionOf = Invoke<position_of<I, Tuples...>>;

        template <typename Tuple, typename Indices = IndicesFor<Tuple>>
        struct to_std_tuple;
        template <typename Tuple, int... Indices>
        struct to_std_tuple<Tuple, indices<Indices...>> : identity<std::tuple<TupleElement<Indices, Tuple>...>> {};
        template <typename Tuple>
        using ToStdTuple = Invoke<to_std_tuple<Tuple>>;

        template <typename Acc, typename... Tuples>
        struct concat_tuples_impl : identity<Acc> {};
        template <typename... Acc, typename... Heads, typename... Tail>
        struct concat_tuples_impl<tuple<Acc...>, std::tuple<Heads...>, Tail...>
        : concat_tuples_impl<tuple<Acc..., Heads...>, Tail...> {};
        template <typename... Tuples>
        struct concat_tuples : concat_tuples_impl<tuple<>, ToStdTuple<Bare<Tuples>>...> {};
        template <typename... Tuples>
        using ConcatTuples = Invoke<concat_tuples<Tuples...>>;

        template <typename P, typename Tuple,
                  typename Inner = TupleElement<P::x, Bare<Tuple>>,
                  typename Outer = TupleElement<P::y, Bare<Inner>>,
                  typename Result = WithQualificationsOf<Inner, Outer>>
        Result get_position(Tuple t) {
            using std::get;
            return get<P::y>(get<P::x>(t));
        }

        template <int... Indices, typename... Tuples>
        auto forward_cat(indices<Indices...>, Tuples&&... t)
        -> decltype(std::forward_as_tuple(
                        get_position<PositionOf<Indices, Tuples...>>(
                            std::forward_as_tuple(std::forward<Tuples>(t)...))...)) {
            return std::forward_as_tuple(
                        get_position<PositionOf<Indices, Tuples...>>(
                            std::forward_as_tuple(std::forward<Tuples>(t)...))...);
        }

        // Goat sacrifice for GCC
        template <typename Ts, typename Us>
        struct pairwise_convertible : Bool<false> {};
        template <>
        struct pairwise_convertible<std::tuple<>, std::tuple<>> : Bool<true> {};
        template <typename THead, typename... TTail, typename UHead, typename... UTail>
        struct pairwise_convertible<std::tuple<THead, TTail...>, std::tuple<UHead, UTail...>>
        : All<std::is_convertible<THead, UHead>, pairwise_convertible<std::tuple<TTail...>, std::tuple<UTail...>>> {};
    } // namespace tuple_detail

    template <typename... T>
    struct tuple {
    private:
        using layout_tuple = tuple_detail::OptimalLayoutTuple<T...>;
        using layout_map = tuple_detail::OptimalLayoutMap<T...>;
        using layout_inverse_map = tuple_detail::OptimalLayoutInverseMap<T...>;

        template <typename Other>
        using LayoutFor = tuple_detail::ConvertLayoutMap<typename Other::layout_map, layout_map>;

    public:
        constexpr tuple() = default;

        explicit tuple(T const&... t)
        : inner(tuple_detail::forward_mapped(layout_map{}, t...)) {
            static_assert(All<std::is_copy_constructible<T>...>::value, "all tuple element types must be copy constructible");
        }
     
        // TODO: get this to compile and remove the hack: EnableIf<std::is_convertible<U, T>...> = _>
        template <typename... U,
                  EnableIf<tuple_detail::pairwise_convertible<std::tuple<U...>, std::tuple<T...>>> = _>
        explicit tuple(U&&... u)
        : inner(tuple_detail::forward_mapped(layout_map{}, std::forward<U>(u)...)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        tuple(tuple const&) = default;
        tuple(tuple&&) = default;

        template <typename... U,
                  EnableIf<std::is_constructible<T, U const&>...> = _>
        tuple(tuple<U...> const& t)
        : inner(tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, t.inner)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }
        template <typename... U,
                  EnableIf<std::is_constructible<T, U&&>...> = _>
        tuple(tuple<U...>&& t)
        : inner(tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, std::move(t.inner))) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        template <typename U1, typename U2,
                  EnableIf<std::is_convertible<U1 const&, TupleElement<0, std::tuple<T...>>>,
                           std::is_convertible<U2 const&, TupleElement<1, std::tuple<T...>>>> = _>
        tuple(std::pair<U1, U2> const& pair)
        : tuple(pair.first, pair.second) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
        }
        template <typename U1, typename U2,
                  EnableIf<std::is_convertible<U1, TupleElement<0, std::tuple<T...>>>,
                           std::is_convertible<U2, TupleElement<1, std::tuple<T...>>>> = _>
        tuple(std::pair<U1, U2>&& pair)
        : tuple(std::forward<U1>(pair.first), std::forward<U2>(pair.second)) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
        }

        template <typename... U,
                  EnableIf<std::is_constructible<T, U const&>...> = _>
        tuple(std::tuple<U...> const& that)
        : inner(tuple_detail::forward_mapped_tuple(layout_map{}, that)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }
        template <typename... U,
                  EnableIf<std::is_constructible<T, U&&>...> = _>
        tuple(std::tuple<U...>&& that)
        : inner(tuple_detail::forward_mapped_tuple(layout_map{}, std::move(that))) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        template <typename Alloc>
        tuple(std::allocator_arg_t tag, Alloc const& a)
        : inner(tag, a) {}

        template <typename Alloc>
        explicit tuple(std::allocator_arg_t tag, Alloc const& a, T const&... t)
        : inner(tag, a, tuple_detail::forward_mapped(layout_map{}, t...)) {
            static_assert(All<std::is_copy_constructible<T>...>::value, "all tuple element types must be copy constructible");
        }
     
        template <typename Alloc, typename... U,
                  EnableIf<tuple_detail::pairwise_convertible<std::tuple<U...>, std::tuple<T...>>> = _>
        explicit tuple(std::allocator_arg_t tag, Alloc const& a, U&&... u)
        : inner(tag, a, tuple_detail::forward_mapped(layout_map{}, std::forward<U>(u)...)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        template <typename Alloc>
        tuple(std::allocator_arg_t tag, Alloc const& a, tuple const& that)
        : inner(tag, a, that.inner) {}

        template <typename Alloc>
        tuple(std::allocator_arg_t tag, Alloc const& a, tuple&& that)
        : inner(tag, a, std::move(that.inner)) {}

        template <typename Alloc, typename... U,
                  EnableIf<std::is_constructible<T, U const&>...> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, tuple<U...> const& t)
        : inner(tag, a, tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, t.inner)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }
        template <typename Alloc, typename... U,
                  EnableIf<std::is_constructible<T, U&&>...> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, tuple<U...>&& t)
        : inner(tag, a, tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, std::move(t.inner))) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        template <typename Alloc, typename U1, typename U2,
                  EnableIf<std::is_convertible<U1 const&, TupleElement<0, std::tuple<T...>>>,
                           std::is_convertible<U2 const&, TupleElement<1, std::tuple<T...>>>> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, std::pair<U1, U2> const& pair)
        : tuple(tag, a, pair.first, pair.second) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
        }
        template <typename Alloc, typename U1, typename U2,
                  EnableIf<std::is_convertible<U1, TupleElement<0, std::tuple<T...>>>,
                           std::is_convertible<U2, TupleElement<1, std::tuple<T...>>>> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, std::pair<U1, U2>&& pair)
        : tuple(tag, a, std::forward<U1>(pair.first), std::forward<U2>(pair.second)) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
        }

        template <typename Alloc, typename... U,
                  EnableIf<std::is_constructible<T, U const&>...> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, std::tuple<U...> const& that)
        : inner(tag, a, tuple_detail::forward_mapped_tuple(layout_map{}, that)) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }
        template <typename Alloc, typename... U,
                  EnableIf<std::is_constructible<T, U&&>...> = _>
        tuple(std::allocator_arg_t tag, Alloc const& a, std::tuple<U...>&& that)
        : inner(tag, a, tuple_detail::forward_mapped_tuple(layout_map{}, std::move(that))) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
        }

        tuple& operator=(tuple const&) = default;
        tuple& operator=(tuple&&) = default;

        template <typename... U>
        tuple& operator=(tuple<U...> const& t) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
            static_assert(All<std::is_assignable<T&, U const&>...>::value,
                          "all arguments must be assignable to the corresponding element");

            inner = tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, t.inner);
            return *this;
        }
        template <typename... U>
        tuple& operator=(tuple<U...>&& t) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
            static_assert(All<std::is_assignable<T&, U&&>...>::value,
                          "all arguments must be assignable to the corresponding element");

            inner = tuple_detail::forward_mapped_tuple(LayoutFor<tuple<U...>>{}, std::move(t.inner));
            return *this;
        }
     
        template <typename U1, typename U2>
        tuple& operator=(std::pair<U1, U2> const& pair) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
            static_assert(std::is_assignable<TupleElement<0, std::tuple<T...>>&, U1 const&>::value
                          && std::is_assignable<TupleElement<1, std::tuple<T...>>&, U2 const&>::value,
                          "pair elements must be assignable to the corresponding element");
            inner = tuple_detail::forward_mapped(layout_map{}, pair.first, pair.second);
            return *this;
        }
        template <typename U1, typename U2>
        tuple& operator=(std::pair<U1, U2>&& pair) {
            static_assert(sizeof...(T) == 2, "tuple size must be 2");
            static_assert(std::is_assignable<TupleElement<0, std::tuple<T...>>&, U1&&>::value
                          && std::is_assignable<TupleElement<1, std::tuple<T...>>&, U2&&>::value,
                          "pair elements must be assignable to the corresponding element");
            inner = tuple_detail::forward_mapped(layout_map{}, std::forward<U1>(pair.first), std::forward<U2>(pair.second));
            return *this;
        }

        template <typename... U>
        tuple& operator=(std::tuple<U...> const& that) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
            static_assert(All<std::is_assignable<T&, U const&>...>::value,
                          "all arguments must be assignable to the corresponding element");
            inner = tuple_detail::forward_mapped_tuple(layout_map{}, that);
            return *this;
        }
        template <typename... U>
        tuple& operator=(std::tuple<U...>&& that) {
            static_assert(sizeof...(T) == sizeof...(U), "number of constructor parameters must match tuple size");
            static_assert(All<std::is_assignable<T&, U&&>...>::value,
                          "all arguments must be assignable to the corresponding element");
            inner = tuple_detail::forward_mapped_tuple(layout_map{}, std::move(that));
            return *this;
        }

        void swap(tuple& that)
        noexcept(noexcept(std::declval<layout_tuple>().swap(std::declval<layout_tuple>()))) {
            inner.swap(that.inner);
        }

        template <std::size_t I, typename... T1>
        friend TupleElement<I, std::tuple<T1...>>& get(tuple<T1...>& t) noexcept;
        template <std::size_t I, typename... T1>
        friend TupleElement<I, std::tuple<T1...>>&& get(tuple<T1...>&& t) noexcept;
        template <std::size_t I, typename... T1>
        friend TupleElement<I, std::tuple<T1...>> const& get(tuple<T1...> const& t) noexcept;
        template <typename... L, typename... R>
        friend bool operator==(tuple<L...> const& t, tuple<R...> const& u);
        template <typename... L, typename... R>
        friend bool operator<(tuple<L...> const& t, tuple<R...> const& u);
        template <typename...>
        friend class tuple;
     
    private:
        layout_tuple inner;
    };

    template <typename... T>
    tuple<UnwrapReference<Decay<T>>...> make_tuple(T&&... t) {
        return tuple<UnwrapReference<Decay<T>>...>(std::forward<T>(t)...);
    }

    template <typename... T>
    tuple<T&&...> forward_as_tuple(T&&... t) noexcept {
        return tuple<T&&...>(std::forward<T>(t)...);
    }

    template <typename... T>
    tuple<T&...> tie(T&... t) noexcept {
        return tuple<T&...>(t...);
    }

    template <typename... Tuples,
              typename Concatenated = tuple_detail::ConcatTuples<Tuples...>>
    Concatenated tuple_cat(Tuples&&... t) {
        return Concatenated {
                tuple_detail::forward_cat(
                    BuildIndices<tuple_detail::sum<std::tuple_size<Bare<Tuples>>...>::value>{},
                    std::forward<Tuples>(t)...)
        };
    }

    template <std::size_t I, typename... T>
    TupleElement<I, std::tuple<T...>>& get(tuple<T...>& t) noexcept {
        return std::get<TupleElement<I, typename tuple<T...>::layout_inverse_map>::value>(t.inner);
    }
    template <std::size_t I, typename... T>
    TupleElement<I, std::tuple<T...>>&& get(tuple<T...>&& t) noexcept {
        return std::get<TupleElement<I, typename tuple<T...>::layout_inverse_map>::value>(std::move(t.inner));
    }
    template <std::size_t I, typename... T>
    TupleElement<I, std::tuple<T...>> const& get(tuple<T...> const& t) noexcept {
        return std::get<TupleElement<I, typename tuple<T...>::layout_inverse_map>::value>(t.inner);
    }

    template <typename... T>
    void swap(tuple<T...>& x, tuple<T...>& y) noexcept(std::declval<tuple<T...>&>().swap(std::declval<tuple<T...>&>())) {
        x.swap(y);
    }

    template <typename... T, typename... U>
    bool operator==(tuple<T...> const& t, tuple<U...> const& u) {
        return t.inner == u.inner;
    }
    template <typename... T, typename... U>
    bool operator<(tuple<T...> const& t, tuple<U...> const& u) {
        return t.inner < u.inner;
    }
    template <typename... T, typename... U>
    bool operator!=(tuple<T...> const& t, tuple<U...> const& u) {
        return !(t == u);
    }
    template <typename... T, typename... U>
    bool operator>(tuple<T...> const& t, tuple<U...> const& u) {
        return u < t;
    }
    template <typename... T, typename... U>
    bool operator<=(tuple<T...> const& t, tuple<U...> const& u) {
        return !(u < t);
    }
    template <typename... T, typename... U>
    bool operator>=(tuple<T...> const& t, tuple<U...> const& u) {
        return !(t < u);
    }
#endif // defined(WHEELS_STD_TUPLE_LAYOUT_OPTIMAL) || defined(WHEELS_STD_TUPLE_LAYOUT_UNKNOWN)
} // namespace wheels

namespace std {
    template <typename... T>
    struct tuple_size< ::wheels::tuple<T...>> : tuple_size<tuple<T...>> {};

    template <size_t I, typename... T>
    struct tuple_element<I, ::wheels::tuple<T...>> : tuple_element<I, tuple<T...>> {};

    template <typename... T, typename Alloc>
    struct uses_allocator< ::wheels::tuple<T...>, Alloc> : true_type {};
} // namespace std

#endif // WHEELS_TUPLE_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Typelists with variadic templates

#ifndef WHEELS_META_TYPELIST_HPP
#define WHEELS_META_TYPELIST_HPP

#include "core.h++"

#include <cstddef>

namespace wheels {
    //! A typelist
    template <typename... T>
    struct typelist {
        using type = typelist;
        using empty = Bool<true>;
    };
    template <typename Head, typename... Tail>
    struct typelist<Head, Tail...> {
        using type = typelist;
        using head = Head;
        using tail = typelist<Tail...>;
        using empty = Bool<false>;
    };
    //! Indices pack
    template <std::size_t... I>
    using Indices = typelist<Const<std::size_t, I>...>;

    //! Indices pack construction
    template <std::size_t Size, typename Acc = typelist<>>
    struct build_indices : typelist<> {};
    template <std::size_t Size, std::size_t... Acc>
    struct build_indices<Size, Indices<Acc...>> : build_indices<Size-1, Indices<Size, Acc...>> {};
    template <std::size_t Size>
    using BuildIndices = Invoke<build_indices<Size>>;
} // namespace wheels

#endif // WHEELS_META_TYPELIST_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Type traits

#ifndef WHEELS_TYPE_TRAITS_HPP
#define WHEELS_TYPE_TRAITS_HPP

#include "../detail/config.h++"
#include "core.h++"

#include <type_traits>
#include <functional>
#include <utility>

#if !WHEELS_HAS_FEATURE(CXX_ALIGNED_UNION)

    // aligned_union emulation
    namespace std {
        template <decltype(sizeof(0)) Len, typename... T>
        struct aligned_union;
    } // namespace std

#endif // !WHEELS_HAS_FEATURE(CXX_ALIGNED_UNION)

namespace wheels {
    // const-volatile modifications
    //! Removes top-level const
    template <typename T>
    using RemoveConst = Invoke<std::remove_const<T>>;
    //! Removes top-level volatile
    template <typename T>
    using RemoveVolatile = Invoke<std::remove_volatile<T>>;
    //! Removes top-level cv-qualifiers
    template <typename T>
    using RemoveCv = Invoke<std::remove_cv<T>>;
    //! Adds top-level const
    template <typename T>
    using AddConst = Invoke<std::add_const<T>>;
    //! Adds top-level volatile
    template <typename T>
    using AddVolatile = Invoke<std::add_volatile<T>>;
    //! Adds top-level const and volatile
    template <typename T>
    using AddCv = Invoke<std::add_cv<T>>;

    // reference modifications
    //! Removes reference qualifiers
    template <typename T>
    using RemoveReference = Invoke<std::remove_reference<T>>;
    //! Adds an lvalue reference qualifier
    template <typename T>
    using AddLvalueReference = Invoke<std::add_lvalue_reference<T>>;
    //! Adds an rvalue reference qualifier
    /*! Reference collapsing rules apply */
    template <typename T>
    using AddRvalueReference = Invoke<std::add_rvalue_reference<T>>;

    // sign modifications
    //! Obtains the signed counterpart of a given type
    template <typename T>
    using MakeSigned = Invoke<std::make_signed<T>>;
    //! Obtains the unsigned counterpart of a given type
    template <typename T>
    using MakeUnsigned = Invoke<std::make_unsigned<T>>;

    // array modifications
    //! Removes an array type's top-level extent
    template <typename T>
    using RemoveExtent = Invoke<std::remove_extent<T>>;
    //! Removes all the extents of an array type
    template <typename T>
    using RemoveAllExtents = Invoke<std::remove_all_extents<T>>;

    // pointer modifications
    //! Removes a pointer qualifier
    template <typename T>
    using RemovePointer = Invoke<std::remove_pointer<T>>;
    //! Adds a pointer qualifier
    template <typename T>
    using AddPointer = Invoke<std::add_pointer<T>>;

    namespace traits_detail {
        template <typename>
        struct extract_alignment;
        template <std::size_t Len, std::size_t Align>
        struct extract_alignment<std::aligned_storage<Len, Align>> : std::integral_constant<std::size_t, Align> {};

        template <std::size_t Len>
        struct default_alignment : extract_alignment<std::aligned_storage<Len>> {};
    } // namespace traits_detail

    // other transformations
    //! Provides storage with the given length and alignment
    template <std::size_t Len, std::size_t Align = traits_detail::default_alignment<Len>::value>
    using AlignedStorage = Invoke<std::aligned_storage<Len, Align>>;
    //! Provides storage properly aligned for the given types
    template <std::size_t Len, typename... T>
    using AlignedUnion = Invoke<std::aligned_union<Len, T...>>;
    //! Emulates pass-by-value semantics
    template <typename T>
    using Decay = Invoke<std::decay<T>>;
    //! Removes all reference and cv qualifiers
    template <typename T>
    using Bare = RemoveCv<RemoveReference<T>>;

    //! ???
    template <typename... T>
    using CommonType = Invoke<std::common_type<T...>>;
    //! Obtains the underlying type of an enum
    template <typename T>
    using UnderlyingType = Invoke<std::underlying_type<T>>;

    // propagations
    //! Produces Destination as const if Source is const
    template <typename Source, typename Destination>
    using WithConstOf = Conditional<std::is_const<Source>, AddConst<Destination>, Destination>;
    //! Produces Destination as volatile if Source is volatile
    template <typename Source, typename Destination>
    using WithVolatileOf = Conditional<std::is_volatile<Source>, AddVolatile<Destination>, Destination>;
    //! Produces Destination as const if Source is const, and volatile if Source is volatile
    template <typename Source, typename Destination>
    using WithCvOf = WithConstOf<Source, WithVolatileOf<Source, Destination>>;

    //! Produces Destination with the same value category of Source
    template <typename Source, typename Destination>
    using WithValueCategoryOf =
        Conditional<std::is_lvalue_reference<Source>,
            AddLvalueReference<Destination>,
            Conditional<std::is_rvalue_reference<Source>,
                AddRvalueReference<Destination>,
                Destination
            >
        >;

    //! Produces Destination with the same reference and cv-qualifiers of Source
    template <typename Source, typename Destination>
    using WithQualificationsOf = WithValueCategoryOf<Source, WithCvOf<RemoveReference<Source>, Destination>>;

    // other traits
    //! Tests if two types are the same after stripping all qualifiers
    template <typename T, typename U>
    using is_related = std::is_same<Bare<T>, Bare<U>>;

    //! Obtains the value_type nested type of T
    template <typename T>
    struct value_type { using type = typename T::value_type; };

    //! Template alias to obtain the value_type nested type of T
    template <typename T>
    using ValueType = Invoke<value_type<T>>;

    //! Tests if T is a specialization of Template
    template <typename T, template <typename...> class Template>
    struct is_specialization_of : Bool<false> {};
    template <template <typename...> class Template, typename... Args>
    struct is_specialization_of<Template<Args...>, Template> : Bool<true> {};

    //! Provides storage properly aligned for any given T
    template <typename... T>
    struct storage_for : std::aligned_union<1, T...> {};
    template <typename T>
    struct storage_for<T> : std::aligned_storage<sizeof(T), alignof(T)> {};
    template <typename... T>
    using StorageFor = Invoke<storage_for<T...>>;

    //! Obtains the class of a member function pointer
    template <typename T>
    struct class_of : identity<T> {};
    template <typename Signature, typename Class>
    struct class_of<Signature Class::*> : identity<Class> {};
    template <typename T>
    using ClassOf = Invoke<class_of<T>>;
    //! Obtains the function type of a member function pointer
    template <typename T>
    struct signature_of : identity<T> {};
    template <typename Signature, typename Class>
    struct signature_of<Signature Class::*> : identity<Signature> {};
    template <typename T>
    using SignatureOf = Invoke<signature_of<T>>;

    namespace invoke_detail {
        template <typename Fun, typename Obj, typename... Args,
                  EnableIf<std::is_member_function_pointer<Bare<Fun>>,
                           std::is_base_of<ClassOf<Bare<Fun>>, Bare<Obj>>
                          > = _>
        auto invoke(Fun&& fun, Obj&& obj, Args&&... args)
        -> decltype((std::declval<Obj>().*std::declval<Fun>())(std::declval<Args>()...)) {
            return (std::forward<Obj>(obj).*std::forward<Fun>(fun))(std::forward<Args>(args)...);
        }

        template <typename Fun, typename Obj, typename... Args,
                  EnableIf<std::is_member_function_pointer<Bare<Fun>>,
                           Not<std::is_base_of<ClassOf<Bare<Fun>>, Bare<Obj>>>
                          > = _>
        auto invoke(Fun&& fun, Obj&& obj, Args&&... args)
        -> decltype(((*std::declval<Obj>()).*std::declval<Fun>())(std::declval<Args>()...)) {
            return ((*std::forward<Obj>(obj)).*std::forward<Fun>(fun))(std::forward<Args>(args)...);
        }

        template <typename Fun, typename Obj,
                  EnableIf<std::is_member_object_pointer<Bare<Fun>>,
                           std::is_base_of<ClassOf<Bare<Fun>>, Bare<Obj>>
                          > = _>
        auto invoke(Fun&& fun, Obj&& obj)
        -> decltype(std::declval<Obj>().*std::declval<Fun>()) {
            return std::forward<Obj>(obj).*std::forward<Fun>(fun);
        }

        template <typename Fun, typename Obj,
                  EnableIf<std::is_member_object_pointer<Bare<Fun>>,
                           Not<std::is_base_of<ClassOf<Bare<Fun>>, Bare<Obj>>>
                          > = _>
        auto invoke(Fun&& fun, Obj&& obj)
        -> decltype((*std::declval<Obj>()).*std::declval<Fun>()) {
            return (*std::forward<Obj>(obj)).*std::forward<Fun>(fun);
        }

        template <typename Fun, typename... Args,
                  DisableIf<std::is_member_pointer<Bare<Fun>>> = _>
        auto invoke(Fun&& fun, Args&&... args)
        -> decltype(std::declval<Fun>()(std::declval<Args>()...)) {
            return std::forward<Fun>(fun)(std::forward<Args>(args)...);
        }
    } // namespace invoke_detail

    //! Tests if a type is deduced
    /*! Works in conjunction with the type `deduced` */
    template <typename T>
    using is_deduced = std::is_same<T, deduced>;

    //! INVOKE semantics from [func.require]
    template <typename Result = deduced, typename... T,
              EnableIf<is_deduced<Result>> = _>
    auto invoke(T&&... t)
    -> decltype(invoke_detail::invoke(std::declval<T>()...)) {
        return invoke_detail::invoke(std::forward<T>(t)...);
    }

    template <typename Result = deduced, typename... T,
              EnableIf<Not<is_deduced<Result>>,
                       Bool<true, decltype(invoke_detail::invoke(std::declval<T>()...))>,
                       std::is_void<Result>
                      > = _>
    void invoke(T&&... t) {
        invoke_detail::invoke(std::forward<T>(t)...);
    }

    template <typename Result = deduced, typename... T,
              EnableIf<Not<is_deduced<Result>>,
                       Not<std::is_void<Result>>,
                       std::is_convertible<decltype(invoke_detail::invoke(std::declval<T>()...)), Result>
                      > = _>
    Result invoke(T&&... t) {
        return invoke_detail::invoke(std::forward<T>(t)...);
    }

    //! Tests if T is callable with the given Signature
    template <typename T, typename Signature, typename = void>
    struct is_callable : Bool<false> {
        static_assert(std::is_function<Signature>::value, "Signature must be a function type");
    };
    template <typename Fun, typename Ret, typename... Args>
    struct is_callable<Fun, Ret(Args...),
                       Void<decltype(invoke<Ret>(std::declval<Fun>(), std::declval<Args>()...))>>
    : Bool<true> {};

    namespace result_of_detail {
        template <typename T, bool Callable>
        struct impl {};
        template <typename Fun, typename... Args>
        struct impl<Fun(Args...), true> : identity<decltype(invoke(std::declval<Fun>(), std::declval<Args>()...))> {};
    } // namespace result_of_detail
    //! Computes the result of a functor given a set of arguments
    /*! Contrary to std::result_of, it SFINAEs */
    template <typename T>
    struct result_of; // { static_assert(Bool<false, T>::value, "Parameter must be a signature"); };
    template <typename Fun, typename... Args>
    struct result_of<Fun(Args...)> : result_of_detail::impl<Fun(Args...), is_callable<Fun, void(Args...)>::value> {};
    template <typename T>
    using ResultOf = Invoke<result_of<T>>;

    //! Tests if T is a function object type ([function.objects])
    template <typename T, typename Signature>
    struct is_function_object : All<std::is_object<T>, Not<std::is_member_pointer<T>>, is_callable<T, Signature>> {};

    //! Tests if T is a pointer to a function
    template <typename T>
    struct is_function_pointer : All<std::is_pointer<T>, std::is_function<RemovePointer<T>>> {};

    //! Obtains the first element of a parameter pack
    template <typename... T>
    struct pack_head {};
    template <typename Head, typename... Tail>
    struct pack_head<Head, Tail...> : identity<Head> {};
    template <typename... T>
    using PackHead = Invoke<pack_head<T...>>;

    //! Removes function qualifiers from a function or pointer to member function type
    template <typename T>
    struct remove_function_qualifiers : identity<T> {};
    template <typename Class, typename Signature>
    struct remove_function_qualifiers<Signature Class::*> : identity<Invoke<remove_function_qualifiers<Signature>> Class::*> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...)> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) volatile> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const volatile> : identity<Ret(Args...)> {};
#if WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...)&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) volatile&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const volatile&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...)&&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const&&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) volatile&&> : identity<Ret(Args...)> {};
    template <typename Ret, typename... Args>
    struct remove_function_qualifiers<Ret(Args...) const volatile&&> : identity<Ret(Args...)> {};
#endif // WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename T>
    using RemoveFunctionQualifiers = Invoke<remove_function_qualifiers<T>>;

    namespace qualifier_detail {
        struct carrier;
    } // namespace qualifier_detail

    //! Converts function qualifiers to object qualifiers
    template <typename T>
    struct from_function_qualifiers : identity<T> {};
    template <typename Class, typename Signature>
    struct from_function_qualifiers<Signature Class::*> : identity<from_function_qualifiers<Signature>>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...)> : identity<qualifier_detail::carrier>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const> : identity<qualifier_detail::carrier const>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) volatile> : identity<qualifier_detail::carrier volatile>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const volatile> : identity<qualifier_detail::carrier const volatile>  {};
#if WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...)&> : identity<qualifier_detail::carrier>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const&> : identity<qualifier_detail::carrier const>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) volatile&> : identity<qualifier_detail::carrier volatile>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const volatile&> : identity<qualifier_detail::carrier const volatile>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...)&&> : identity<qualifier_detail::carrier&&>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const&&> : identity<qualifier_detail::carrier const&&>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) volatile&&> : identity<qualifier_detail::carrier volatile&&>  {};
    template <typename Ret, typename... Args>
    struct from_function_qualifiers<Ret(Args...) const volatile&&> : identity<qualifier_detail::carrier const volatile&&>  {};
#endif // WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename Fun>
    using FromFunctionQualifiers = Invoke<from_function_qualifiers<Fun>>;

    //! Converts object qualifiers to function qualifiers
    template <typename Q>
    struct to_function_qualifiers : identity<qualifier_detail::carrier()> {};
    template <typename Q>
    struct to_function_qualifiers<Q const> : identity<qualifier_detail::carrier() const>  {};
    template <typename Q>
    struct to_function_qualifiers<Q volatile> : identity<qualifier_detail::carrier() volatile>  {};
    template <typename Q>
    struct to_function_qualifiers<Q const volatile> : identity<qualifier_detail::carrier() const volatile>  {};
#if WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename Q>
    struct to_function_qualifiers<Q&> : identity<qualifier_detail::carrier()&> {};
    template <typename Q>
    struct to_function_qualifiers<Q const&> : identity<qualifier_detail::carrier() const&>  {};
    template <typename Q>
    struct to_function_qualifiers<Q volatile&> : identity<qualifier_detail::carrier() volatile&>  {};
    template <typename Q>
    struct to_function_qualifiers<Q const volatile&> : identity<qualifier_detail::carrier() const volatile&>  {};
    template <typename Q>
    struct to_function_qualifiers<Q&&> : identity<qualifier_detail::carrier()&&> {};
    template <typename Q>
    struct to_function_qualifiers<Q const&&> : identity<qualifier_detail::carrier() const&&>  {};
    template <typename Q>
    struct to_function_qualifiers<Q volatile&&> : identity<qualifier_detail::carrier() volatile&&>  {};
    template <typename Q>
    struct to_function_qualifiers<Q const volatile&&> : identity<qualifier_detail::carrier() const volatile&&>  {};
#endif // WHEELS_HAS_FEATURE(CXX_REFERENCE_QUALIFIED_FUNCTIONS)
    template <typename Q>
    using ToFunctionQualifiers = Invoke<to_function_qualifiers<Q>>;

    //! Unwraps a reference_wrapper type
    template <typename T>
    struct unwrap_reference : identity<T> {};
    template <typename T>
    struct unwrap_reference<std::reference_wrapper<T>> : identity<T&> {};
    template <typename T>
    using UnwrapReference = Invoke<unwrap_reference<T>>;
    //! Unwraps a reference_wrapper
    template <typename T>
    T&& unref(T&& t) { return std::forward<T>(t); }
    template <typename T>
    T& unref(std::reference_wrapper<T> t) { return t.get(); }

    //! Tests if a type is not a reference and has no cv-qualifiers
    template <typename T>
    struct is_bare : std::is_same<T, Bare<T>> {};

    template <typename Tester, typename... T>
    using TraitOf = decltype(Tester::template test<T...>(0));
} // namespace wheels

#if !WHEELS_HAS_FEATURE(CXX_ALIGNED_UNION)

    // aligned_union emulation
    namespace std {
        template <decltype(sizeof(0)) Len, typename... T>
        struct aligned_union
        : ::std::aligned_storage<
              ::wheels::max< ::std::integral_constant<decltype(sizeof(0)), Len>, ::std::integral_constant<decltype(sizeof(0)), sizeof(T)>...>::value,
              ::wheels::max< ::std::integral_constant<decltype(sizeof(0)), alignof(T)>...>::value> {
            static constexpr size_t alignment_value = alignof(::wheels::Invoke<aligned_union>);
        };
    } // namespace std
    #define WHEELS_HAS_FEATURE_CXX_ALIGNED_UNION

#endif // !WHEELS_HAS_FEATURE(CXX_ALIGNED_UNION)

#endif // WHEELS_TYPE_TRAITS_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Core meta-programming facilities

#ifndef WHEELS_META_CORE_HPP
#define WHEELS_META_CORE_HPP

#include <type_traits>

#include "../detail/config.h++"

namespace wheels {
    //! Metafunction invocation
    template <typename T>
    using Invoke = typename T::type;

    //! Identity metafunction
    template <typename T>
    struct identity {
        using type = T;
    };

    //! Identity template alias
    template <typename T>
    using Identity = Invoke<identity<T>>;
    //! Deducible identity template alias
    template <typename T>
    using Alias = T;
    //! Not deducible identity template alias
    template <typename T>
    using NotDeducible = Identity<T>;

    //! Meta-boolean type with parameters for when dependent contexts are needed
    template <bool B, typename...>
    struct dependent_bool_type : std::integral_constant<bool, B> {};

    //! Boolean integral_constant alias
    template <bool B, typename... T>
    using Bool = Invoke<dependent_bool_type<B, T...>>;

    //! integral_constant alias
    template <typename T, T I>
    using Const = std::integral_constant<T, I>;

    //! Integer integral_constant alias
    template <int I>
    using Int = Const<decltype(I), I>;

    //! Constant void metafunction
    template <typename>
    struct void_ : identity<void> {};
    template <typename T>
    using Void = Invoke<void_<T>>;

    template <typename... T>
    struct count : Int<0> {};
    template <typename Head, typename... Tail>
    struct count<Head, Tail...> : Int<(Head::value? 1 : 0) + count<Tail...>::value> {};

    //! If-then-else metafunction
    template <typename Condition, typename Then, typename Else>
    using Conditional = Invoke<std::conditional<Condition::value, Then, Else>>;

    //! Logical negation metafunction
    template <typename T>
    using Not = Bool<!T::value>;

    //! Logical disjunction metafunction
    template <typename... T>
    struct Any : Bool<false> {};
    template <typename Head, typename... Tail>
    struct Any<Head, Tail...> : Conditional<Head, Bool<true>, Any<Tail...>> {};

    //! Logical conjunction metafunction
    template <typename... T>
    struct All : Bool<true> {};
    template <typename Head, typename... Tail>
    struct All<Head, Tail...> : Conditional<Head, All<Tail...>, Bool<false>> {};

    //! Minimum metafunction
    template <typename Head, typename... Tail>
    struct min : Head {};
    template <typename T, typename U, typename... Tail>
    struct min<T, U, Tail...> : min<Conditional<Bool<(T::value < U::value)>, T, U>, Tail...> {};

    //! Maximum metafunction
    template <typename Head, typename... Tail>
    struct max : Head {};
    template <typename T, typename U, typename... Tail>
    struct max<T, U, Tail...> : max<Conditional<Bool<(T::value > U::value)>, T, U>, Tail...> {};

    namespace meta_detail {
        enum class enabler { _ };
    } // namespace meta_detail
    //! Dummy for defaulting EnableIf
    constexpr auto _ = meta_detail::enabler::_;
    //! SFINAE enabler
    template <typename... T>
    using EnableIf = Invoke<std::enable_if<All<T...>::value, decltype(_)>>;
    //! SFINAE disabler
    template <typename... T>
    using DisableIf = Invoke<std::enable_if<Not<All<T...>>::value, decltype(_)>>;

    //! Marker for deducible template type parameters
    struct deduced;
} // namespace wheels

#endif // WHEELS_META_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Overloaded function object

#ifndef WHEELS_OVERLOAD_HPP
#define WHEELS_OVERLOAD_HPP

#include "meta.h++"

#include "detail/config.h++"

#include <boost/preprocessor/repetition/enum.hpp>

namespace wheels {
    namespace overload_detail {
        template <typename Fun>
        class simple_overload_element : Fun {
        public:
            simple_overload_element() = default;

            template <typename T,
                      DisableIf<is_related<simple_overload_element, T>> = _>
            explicit simple_overload_element(T&& t)
            : Fun(std::forward<T>(t)) {}

            using Fun::operator();
        };

        template <typename Ret, typename... Args>
        class simple_overload_element<Ret(*)(Args...)> {
            using fun_type = Ret(*)(Args...);
        public:
            simple_overload_element() = delete;

            template <typename T,
                      DisableIf<is_related<simple_overload_element, T>> = _>
            explicit simple_overload_element(T&& t)
            : fun_ptr(std::forward<T>(t)) {}

            Ret operator()(Args... args) const {
                return fun_ptr(std::forward<Args>(args)...);
            }

        private:
            fun_type fun_ptr;
        };

        template <typename Class, typename Ret>
        class simple_overload_element<Ret Class::*> {
            using mem_obj_type = Ret Class::*;
        public:
            simple_overload_element() = delete;

            template <typename T,
                      DisableIf<is_related<simple_overload_element, T>> = _>
            explicit simple_overload_element(T&& t)
            : mem_obj_ptr(std::forward<T>(t)) {}

            template <typename C,
                      EnableIf<Any<is_related<Class, C>, std::is_base_of<Class, C>>> = _>
            WithQualificationsOf<C, Ret> operator()(C&& c) const {
                return std::forward<C>(c).*mem_obj_ptr;
            }

            mem_obj_type mem_obj_ptr;
        };

        template <typename T, typename Signature>
        struct mem_fun_overload_element_impl;
        template <typename T>
        struct mem_fun_overload_element {
            using type = mem_fun_overload_element_impl<T, RemoveFunctionQualifiers<T>>;
        };
        template <typename T>
        using overload_element = Invoke<Conditional<
                                    std::is_member_function_pointer<T>,
                                    mem_fun_overload_element<T>,
                                    identity<simple_overload_element<T>>
                                 >>;

        template <typename Class, typename Signature, typename Ret, typename... Args>
        class mem_fun_overload_element_impl<Signature Class::*, Ret (Class::*)(Args...)> {
            using mem_fun_type = Signature Class::*;
            using qualifiers = FromFunctionQualifiers<Signature>;
        public:
            mem_fun_overload_element_impl() = delete;
            template <typename T,
                      DisableIf<is_related<mem_fun_overload_element_impl, T>> = _>
            explicit mem_fun_overload_element_impl(T&& t)
            : mem_fun_ptr(std::forward<T>(t)) {}

            template <typename Qualifiers = qualifiers,
                      DisableIf<std::is_reference<Qualifiers>> = _>
            Ret operator()(WithCvOf<qualifiers, Class>& c, Args&&... args) const {
                return (c.*mem_fun_ptr)(std::forward<Args>(args)...);
            }
            template <typename Qualifiers = qualifiers,
                      DisableIf<std::is_reference<Qualifiers>> = _>
            Ret operator()(WithCvOf<qualifiers, Class>&& c, Args&&... args) const {
                return (std::move(c).*mem_fun_ptr)(std::forward<Args>(args)...);
            }
            template <typename Qualifiers = qualifiers,
                      EnableIf<std::is_reference<Qualifiers>> = _>
            Ret operator()(WithQualificationsOf<qualifiers, Class> c, Args&&... args) const {
                return (std::forward<WithQualificationsOf<qualifiers, Class>>(c).*mem_fun_ptr)(std::forward<Args>(args)...);
            }
            Ret operator()(WithCvOf<RemoveReference<qualifiers>, Class>* c, Args&&... args) const {
                return (c->*mem_fun_ptr)(std::forward<Args>(args)...);
            }
        private:
            mem_fun_type mem_fun_ptr;
        };

        template <typename... Funs>
        class overload_impl {};
        template <typename Fun>
        class overload_impl<Fun> : overload_element<Decay<Fun>> {
            using element_type = overload_element<Decay<Fun>>;
        public:
            overload_impl() = default;

            template <typename T,
                      DisableIf<is_related<overload_impl, T>> = _>
            explicit overload_impl(T&& t)
            : element_type(std::forward<T>(t)) {}

            using element_type::operator();
        };
        template <typename Head, typename... Tail>
        class overload_impl<Head, Tail...> : overload_element<Decay<Head>>, overload_impl<Tail...> {
            using head_type = overload_element<Decay<Head>>;
            using tail_type = overload_impl<Tail...>;
        public:
            overload_impl() = default;

            template <typename H, typename... T,
                      DisableIf<is_related<overload_impl, H>> = _>
            explicit overload_impl(H&& h, T&&... t)
            : head_type(std::forward<H>(h))
            , tail_type(std::forward<T>(t)...) {}

            using head_type::operator();
            using tail_type::operator();
        };
    } // namespace overload_detail

    template <typename... Funs>
    class overload : overload_detail::overload_impl<Funs...> {
        using impl_type = overload_detail::overload_impl<Funs...>;
    public:
        overload() = default;

        template <typename... T,
                  DisableIf<is_related<overload, PackHead<T...>>> = _>
        explicit overload(T&&... t)
        : impl_type(std::forward<T>(t)...) {}

        using impl_type::operator();
    };

    template <typename... Funs, 
              typename Overload = overload<Decay<Funs>...>
             >
    Overload make_overload(Funs&&... funs) {
        return Overload { std::forward<Funs>(funs)... };
    }

#ifndef WHEELS_MAKE_OVERLOAD_MAX_ARITY
# define WHEELS_MAKE_OVERLOAD_MAX_ARITY 17
#endif // WHEELS_MAKE_OVERLOAD_MAX_ARITY

#define WHEELS_OVERLOAD_PASTE(A, B, TEXT) TEXT
#define WHEELS_OVERLOAD(NAME) BOOST_PP_ENUM(WHEELS_MAKE_OVERLOAD_MAX_ARITY, WHEELS_OVERLOAD_PASTE, NAME)

    template <typename Head, typename... Tail,
              EnableIf<Any<is_function_pointer<Decay<Head>>
                         , std::is_member_pointer<Head>>> = _,
              typename Overload = overload<Head, Tail...>>
    Overload make_overload(Decay<Head> head, Decay<Tail>... tail, WHEELS_OVERLOAD(Decay<Head> = nullptr)) {
        return Overload { head, tail... };
    }

    template <typename Result, typename... Funs>
    struct visitor : overload<Funs...> {
        using fun_type = overload<Funs...>;
    public:
        using result_type = Result;

        template <typename... T,
                  DisableIf<is_related<visitor, PackHead<T...>>> = _>
        explicit visitor(T&&... t)
        : fun_type(std::forward<T>(t)...) {}

        using fun_type::operator();
    };

    template <typename Result = void,
              typename... Funs, 
              typename Visitor = visitor<Result, Decay<Funs>...>
             >
    Visitor make_visitor(Funs&&... funs) {
        return Visitor { std::forward<Funs>(funs)... };
    }
} // namespace wheels

#endif // WHEELS_OVERLOAD_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Allocator utilities

#ifndef WHEELS_ALLOCATOR_HPP
#define WHEELS_ALLOCATOR_HPP

#include "meta.h++"

#include <cstddef>
#include <memory>

namespace wheels {
    namespace allocator_detail {
        template <typename A>
        struct deallocate {
        public:
            deallocate(A& a, std::size_t n) : a(a), n(n) {}

            void operator()(typename std::allocator_traits<A>::pointer ptr) {
                a.deallocate(ptr, n);
            }

        private:
            A& a;
            std::size_t n;
        };

        template <typename A,
                  typename Pointer = std::unique_ptr<ValueType<A>, deallocate<A>>>
        Pointer allocate(A& a, std::size_t n) {
            return Pointer { a.allocate(n), deallocate<A> { a, n } };
        }
    } // namespace allocator_detail

    //! Allocator-based copier
    template <typename T, typename Alloc>
    struct allocator_cloner {
    public:
        allocator_cloner(Alloc a) : a(std::move(a)) {}

        T* operator()(T* ptr) {
            auto holder = allocator_detail::allocate(a, 1);
            ::new(holder.get()) T(*ptr);
            return holder.release();
        }

    private:
        Alloc a;
    };

    //! Allocator-based deleter
    template <typename T, typename Alloc>
    struct allocator_delete {
    public:
        allocator_delete(Alloc a) : a(std::move(a)) {}

        void operator()(T* ptr) {
            ptr->~T();
            a.deallocate(ptr, 1);
        }

    private:
        Alloc a;
    };
} // namespace wheels

#endif // WHEELS_ALLOCATOR_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Iterator utilities

#ifndef WHEELS_ITERATOR_H
#define WHEELS_ITERATOR_H

namespace wheels {
    template <typename T>
    using Iterator = typename T::iterator;
    template <typename T>
    using ConstIterator = typename T::const_iterator;

    template <typename Container>
    ConstIterator<Container> cbegin(Container const& container) {
        return container.begin();
    }
    template <typename Container>
    ConstIterator<Container> cend(Container const& container) {
        return container.end();
    }
} // namespace wheels

#endif // WHEELS_ITERATOR_H
// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Alignment tool utilities

#ifndef WHEELS_ALIGN_HPP
#define WHEELS_ALIGN_HPP

//#include "meta.h++"

#include <cstddef>
#include <memory>
#include <tuple>

namespace wheels {
    //! alternative interface for align
    //! Usage: std::tie(aligned, remaining) = align(16, size, unaligned, total);
    inline std::tuple<void*, std::size_t> align(std::size_t alignment, std::size_t size, void* ptr, std::size_t space) {
        auto r = std::align(alignment, size, ptr, space);
        return std::make_tuple(r, space);
    }
} // namespace wheels

#endif // WHEELS_ALLOCATOR_HPP



// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// Meta-programming facilities

#ifndef WHEELS_META_HPP
#define WHEELS_META_HPP

#include "meta/core.h++"
#include "meta/type_traits.h++"
//#include "meta/typelist.h++"

#endif // WHEELS_META_CORE_HPP

// Wheels - various C++ utilities
//
// Written in 2012 by Martinho Fernandes <martinho.fernandes@gmail.com>
//
// To the extent possible under law, the author(s) have dedicated all copyright and related
// and neighboring rights to this software to the public domain worldwide. This software is
// distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

// A box that enforces the use of a lock to access a value

#ifndef WHEELS_CONCURRENCY_LOCKER_BOX_HPP
#define WHEELS_CONCURRENCY_LOCKER_BOX_HPP

#include "../detail/config.h++"

#if WHEELS_HAS_FEATURE(CXX_THREADS)

#include "../meta.h++"

#include <mutex>
#include <utility>
 
namespace wheels {
    //! A single-value container that enforces synchronised access to the value
    template <typename T, typename BasicLockable = std::mutex>
    struct locker_box {
    public:
        //! Type of the contained value
        using value_type = T;
        //! Type of the guarding mutex
        using mutex_type = BasicLockable;

    private:
        template <typename Box>
        struct cookie {
            cookie() = default;
            cookie(Box& b) : b(&b) {}
     
            WithConstOf<Box, value_type>& operator*() const { return b->value; }
            WithConstOf<Box, value_type>* operator->() { return &b->value; }
            cookie& operator++() {
                b = nullptr;
                return *this;
            }
            cookie operator++(int) {
                cookie copy(*this);
                ++*this;
                return copy;
            }
            bool operator==(cookie const& c) { return b == c.b; }
            bool operator!=(cookie const& c) { return b != c.b; }

        private:
            Box* b = nullptr;
        };
        template <typename Box>
        struct open_box {
            open_box(Box& b) : b(b) { b.m.lock(); }
            ~open_box() { b.m.unlock(); }
            cookie<Box> begin() { return { b }; }
            cookie<Box> end() { return {}; }
        private:
            Box& b;
        };

    public:
        //! Creates a new locker box with a default initialized value
        explicit locker_box() : value{} {}
        //! Creates a new locker box by forwarding the arguments to T's construtor
        template <typename... Args>
        explicit locker_box(Args&&... args) : value(std::forward<Args>(args)...) {}

        //! Gain access to the underlying value
        /*! Remarks: Intended for use in range-based for loops
         *! Example:
         *!     for(auto&& x : box.open()) {
         *!         x.do_stuff();
         *!     }
         */
        open_box<locker_box> open() { return { *this }; }
        //! Gain access to the underlying value
        /*! Remarks: acts just like the non-const version, but provides a const view of the value */
        open_box<locker_box const> open() const { return { *this }; }
     
        //! Obtains the mutex used to guard this instance
        mutex_type const& mutex() const { return m; }

    private:
        template <typename Box>
        friend struct open_box;
        template <typename Box>
        friend struct cookie;

        mutable mutex_type m {};
        value_type value;
    };

    //! Applies a function to the contents of a locker_box
    /*! Returns the function's result, if any */
    template <typename Fun, typename T, typename BasicLockable>
    ResultOf<Fun(T&)> apply(Fun&& fun, locker_box<T, BasicLockable>& box) {
        for(auto&& x : box.open()) { return std::forward<Fun>(fun)(x); }
        WHEELS_UNREACHABLE;
    }
    //! Applies a function to the contents of a locker_box
    /*! Returns the function's result, if any */
    template <typename Fun, typename T, typename BasicLockable>
    ResultOf<Fun(T const&)> apply(Fun&& fun, locker_box<T, BasicLockable> const& box) {
        for(auto&& x : box.open()) { return std::forward<Fun>(fun)(x); }
        WHEELS_UNREACHABLE;
    }
}

#endif // WHEELS_HAS_FEATURE(CXX_THREADS)

#endif // WHEELS_CONCURRENCY_LOCKER_BOX_HPP

