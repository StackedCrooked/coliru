main.cpp: In function 'int main()':
main.cpp:5:32: error: no match for call to '(std::_Bind_helper<false, main()::__lambda0, int>::type {aka std::_Bind<main()::__lambda0(int)>}) ()'
     std::bind([](int&&) {}, 0)();
                                ^
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1280:11: note: candidates are:
     class _Bind<_Functor(_Bound_args...)>
           ^
/usr/local/include/c++/4.8.0/functional:1351:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) [with _Args = {_Args ...}; _Result = _Result; _Functor = main()::__lambda0; _Bound_args = {int}]
  operator()(_Args&&... __args)
  ^
/usr/local/include/c++/4.8.0/functional:1351:2: note:   template argument deduction/substitution failed:
/usr/local/include/c++/4.8.0/functional:1347:37: error: cannot bind 'int' lvalue to 'int&&'
  = decltype( std::declval<_Functor>()(
                                     ^
main.cpp:5:23: error:   initializing argument 1 of 'main()::__lambda0'
     std::bind([](int&&) {}, 0)();
                       ^
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1365:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const [with _Args = {_Args ...}; _Result = _Result; _Functor = main()::__lambda0; _Bound_args = {int}]
  operator()(_Args&&... __args) const
  ^
/usr/local/include/c++/4.8.0/functional:1365:2: note:   template argument deduction/substitution failed:
/usr/local/include/c++/4.8.0/functional:1361:53: error: no match for call to '(const main()::__lambda0) (const int&)'
          typename add_const<_Functor>::type>::type>()(
                                                     ^
main.cpp:5:16: note: candidates are:
     std::bind([](int&&) {}, 0)();
                ^
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1361:53: note: void (*)(int&&) <conversion>
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/local/include/c++/4.8.0/functional:1361:53: note:   candidate expects 2 arguments, 2 provided
main.cpp:5:23: note: main()::__lambda0
     std::bind([](int&&) {}, 0)();
                       ^
main.cpp:5:23: note:   no known conversion for argument 1 from 'const int' to 'int&&'
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1379:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = main()::__lambda0; _Bound_args = {int}]
  operator()(_Args&&... __args) volatile
  ^
/usr/local/include/c++/4.8.0/functional:1379:2: note:   template argument deduction/substitution failed:
/usr/local/include/c++/4.8.0/functional:1375:70: error: no match for call to '(volatile main()::__lambda0) (volatile int&)'
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
main.cpp:5:16: note: candidates are:
     std::bind([](int&&) {}, 0)();
                ^
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1375:70: note: void (*)(int&&) <conversion>
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/local/include/c++/4.8.0/functional:1375:70: note:   candidate expects 2 arguments, 2 provided
main.cpp:5:23: note: main()::__lambda0
     std::bind([](int&&) {}, 0)();
                       ^
main.cpp:5:23: note:   no known conversion for argument 1 from 'volatile int' to 'int&&'
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1393:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = main()::__lambda0; _Bound_args = {int}]
  operator()(_Args&&... __args) const volatile
  ^
/usr/local/include/c++/4.8.0/functional:1393:2: note:   template argument deduction/substitution failed:
/usr/local/include/c++/4.8.0/functional:1389:64: error: no match for call to '(const volatile main()::__lambda0) (const volatile int&)'
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
main.cpp:5:16: note: candidates are:
     std::bind([](int&&) {}, 0)();
                ^
In file included from main.cpp:1:0:
/usr/local/include/c++/4.8.0/functional:1389:64: note: void (*)(int&&) <conversion>
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
/usr/local/include/c++/4.8.0/functional:1389:64: note:   candidate expects 2 arguments, 2 provided
main.cpp:5:23: note: main()::__lambda0
     std::bind([](int&&) {}, 0)();
                       ^
main.cpp:5:23: note:   no known conversion for argument 1 from 'const volatile int' to 'int&&'
