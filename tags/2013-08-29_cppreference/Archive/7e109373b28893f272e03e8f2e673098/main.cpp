/**
 * Problem 12
 * ----------
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
 * first ten terms would be:
 *   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *   10: 1,2,5,10
 *   15: 1,3,5,15
 *   21: 1,3,7,21
 *   28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */


/*
Solution:
 - First 9 prime factors leads to 2^9 + 2 = 514 divisors
 - 2^1 * 3^1
 - p0^k0 + p1*k1 + p2^k2 + ...


 First nine primes are: 2, 3, 5, 7, 11, 13, 17, 19, 23.
 Their product is: 223092870
 Triangle number: 1 + 2 + ... + 223092870 = (223092870/2) + (223092870+1)
 n/2 => number of prime factors is reduced with 1
 n + 1 => number of prime factors is ...?
 n + (n+1) = sum of the number of prime factors of both
 We need 9 prime factors.


n+1


*/


#include <algorithm>
#include <iostream>
#include <map>
#include <vector>
#include <stdint.h>


std::vector<unsigned> prime_factors = {
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
    73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
    157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
    239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
    331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
    421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503
};



template<typename T>
std::ostream& operator<<(std::ostream & os, const std::vector<T> & vec)
{
    os << "{ ";
    for (const auto & v : vec)
    {
        os << v << " ";
    }
    return os << "}";
}

template<typename T>
std::ostream& operator<<(std::ostream & os, const std::map<T, T> & vec)
{
    unsigned c = 0;
    for (const auto & p : vec)
    {
        if (c++)
        {
            os << '*';
        }
        for (unsigned i = 0; i < p.second; ++i)
        {
            if (i != 0)
            {
                os << '*';
            }
            os << p.first;
        }
    }
    return os;
}


bool is_prime(uint64_t n, const std::vector<uint64_t> & preceding)
{
    // precondition: "preceding" contains all primes < sqrt(n)

    for (auto p : preceding)
    {
        if ((p * p) > n)
        {
            return true;
        }

        if (n % p == 0)
        {
            return false;
        }
    }
    return true;
}


uint64_t next_prime(const std::vector<uint64_t> & preceding)
{
    if (preceding.empty())
    {
        return 2;
    }

    if (preceding.back() == 2)
    {
        return 3;
    }

    for (uint64_t n = preceding.back() + 2; ; n += 2)
    {
        if (is_prime(n, preceding))
        {
            return n;
        }
    }
}


std::vector<uint64_t> get_primes_below(uint64_t limit)
{
    std::vector<uint64_t> result;
    result.reserve(limit / 2); // no reallocs
    for (;;)
    {
        uint64_t next = next_prime(result);
        if (next >= limit)
        {
            return result;
        }
        result.push_back(next);
    }
}

std::map<unsigned, unsigned> get_prime_factors(unsigned n)
{
    std::map<unsigned, unsigned> result;
    std::vector<uint64_t> pre = {2};
    for (unsigned i = 2; i <= n; i = next_prime(pre))
    {
        pre.push_back(i);
        auto copy = n;
        while (copy % i == 0)
        {
            result[i]++;
            copy /= i;
        }
    }
    return result;
}


unsigned num_divisors(unsigned n)
{
    unsigned result = 1;
    for (auto pair : get_prime_factors(n))
    {
        result *= (pair.second + 1);
    }
    return result;
}


unsigned triangle(unsigned n)
{
    return n % 2 == 0 ? (n/2) * (n+1) : ((n+1)/2) * n;
}


int main()
{
    for (unsigned i = 0; i < 20; ++i)
    {
        auto tr = triangle(i);
        std::cout << i << "\t" << tr << "\t" << get_prime_factors(tr) << std::endl;
    }
}
