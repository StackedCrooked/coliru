main.cpp: In function 'int main(int, char**)':
main.cpp:136:5: error: 'foo_container_raw' was not declared in this scope
     foo_container_raw.insert(new Foo1());
     ^
main.cpp:141:56: error: base operand of '->' has non-pointer type 'const value_type {aka const Foo1}'
         std::cout << "Found raw: keys: "<<(*it_raw_ptr)->getKey1() << " " <<  (*it_raw_ptr)->getKey2() <<std::endl;
                                                        ^
main.cpp:141:92: error: base operand of '->' has non-pointer type 'const value_type {aka const Foo1}'
         std::cout << "Found raw: keys: "<<(*it_raw_ptr)->getKey1() << " " <<  (*it_raw_ptr)->getKey2() <<std::endl;
                                                                                            ^
In file included from main.cpp:4:0:
/usr/local/include/boost/multi_index/composite_key.hpp: In instantiation of 'typename boost::disable_if<boost::is_convertible<const ChainedPtr&, const Type&>, boost::multi_index::composite_key_result<boost::multi_index::composite_key<Value, KeyFromValue0, KeyFromValue1, KeyFromValue2, KeyFromValue3, KeyFromValue4, KeyFromValue5, KeyFromValue6, KeyFromValue7, KeyFromValue8, KeyFromValue9> > >::type boost::multi_index::composite_key<Value, KeyFromValue0, KeyFromValue1, KeyFromValue2, KeyFromValue3, KeyFromValue4, KeyFromValue5, KeyFromValue6, KeyFromValue7, KeyFromValue8, KeyFromValue9>::operator()(const ChainedPtr&) const [with ChainedPtr = Foo1; Value = Foo1*; KeyFromValue0 = boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>; KeyFromValue1 = boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>; KeyFromValue2 = boost::tuples::null_type; KeyFromValue3 = boost::tuples::null_type; KeyFromValue4 = boost::tuples::null_type; KeyFromValue5 = boost::tuples::null_type; KeyFromValue6 = boost::tuples::null_type; KeyFromValue7 = boost::tuples::null_type; KeyFromValue8 = boost::tuples::null_type; KeyFromValue9 = boost::tuples::null_type; typename boost::disable_if<boost::is_convertible<const ChainedPtr&, const Type&>, boost::multi_index::composite_key_result<boost::multi_index::composite_key<Value, KeyFromValue0, KeyFromValue1, KeyFromValue2, KeyFromValue3, KeyFromValue4, KeyFromValue5, KeyFromValue6, KeyFromValue7, KeyFromValue8, KeyFromValue9> > >::type = boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> >]':
/usr/local/include/boost/multi_index/hashed_index.hpp:445:52:   required from 'boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::iterator boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::find(const CompatibleKey&, const CompatibleHash&, const CompatiblePred&) const [with CompatibleKey = boost::tuples::tuple<int, int, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>; CompatibleHash = boost::hash<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; CompatiblePred = std::equal_to<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; KeyFromValue = boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>; Hash = boost::hash<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; Pred = std::equal_to<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; SuperMeta = boost::multi_index::detail::nth_layer<1, Foo1, boost::multi_index::indexed_by<boost::multi_index::hashed_unique<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>, mpl_::na, mpl_::na, mpl_::na>, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na>, std::allocator<Foo1> >; TagList = boost::mpl::vector0<mpl_::na>; Category = boost::multi_index::detail::hashed_unique_tag; boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::iterator = boost::multi_index::detail::hashed_index_iterator<boost::multi_index::detail::hashed_index_node<boost::multi_index::detail::index_node_base<Foo1, std::allocator<Foo1> > >, boost::multi_index::detail::bucket_array<std::allocator<Foo1> > >; typename SuperMeta::type::final_allocator_type = std::allocator<Foo1>; typename SuperMeta::type::node_type = boost::multi_index::detail::index_node_base<Foo1, std::allocator<Foo1> >]'
/usr/local/include/boost/multi_index/hashed_index.hpp:431:26:   required from 'boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::iterator boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::find(const CompatibleKey&) const [with CompatibleKey = boost::tuples::tuple<int, int, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>; KeyFromValue = boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>; Hash = boost::hash<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; Pred = std::equal_to<boost::multi_index::composite_key_result<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type> > >; SuperMeta = boost::multi_index::detail::nth_layer<1, Foo1, boost::multi_index::indexed_by<boost::multi_index::hashed_unique<boost::multi_index::composite_key<Foo1*, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey1>, boost::multi_index::const_mem_fun<Foo1, int, &Foo1::getKey2>, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type>, mpl_::na, mpl_::na, mpl_::na>, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na>, std::allocator<Foo1> >; TagList = boost::mpl::vector0<mpl_::na>; Category = boost::multi_index::detail::hashed_unique_tag; boost::multi_index::detail::hashed_index<KeyFromValue, Hash, Pred, SuperMeta, TagList, Category>::iterator = boost::multi_index::detail::hashed_index_iterator<boost::multi_index::detail::hashed_index_node<boost::multi_index::detail::index_node_base<Foo1, std::allocator<Foo1> > >, boost::multi_index::detail::bucket_array<std::allocator<Foo1> > >; typename SuperMeta::type::final_allocator_type = std::allocator<Foo1>; typename SuperMeta::type::node_type = boost::multi_index::detail::index_node_base<Foo1, std::allocator<Foo1> >]'
main.cpp:138:110:   required from here
/usr/local/include/boost/multi_index/composite_key.hpp:638:23: error: no match for 'operator*' (operand type is 'const Foo1')
     return operator()(*x);
                       ^
