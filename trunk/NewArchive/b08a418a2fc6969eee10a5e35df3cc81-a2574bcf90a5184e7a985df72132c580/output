main.cpp:24:92: error: expected ')' before '::' token
     -> decltype( std::declval<composed_invoker<L, R, decltype(l(std::forward<Ts>(vs)...))>>::type()( r, l, std::forward<Ts>(vs)... )) { 
                                                                                            ^
main.cpp:24:8: error: expected type-specifier before 'decltype'
     -> decltype( std::declval<composed_invoker<L, R, decltype(l(std::forward<Ts>(vs)...))>>::type()( r, l, std::forward<Ts>(vs)... )) { 
        ^
main.cpp:24:8: error: expected initializer before 'decltype'
main.cpp: In function 'int main()':
main.cpp:74:28: error: no match for call to '(composer<composed_t<composed_t<composed_t<main()::__lambda0, int (*)(int)>, int (*)(int)>, int (*)(int)> >) (int)'
     std::cout << comp1( 10 ) << "\n" << comp2( 10 ) << "\n";
                            ^
main.cpp:32:8: note: candidate is:
 struct composer{
        ^
main.cpp:39:10: note: template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<composed_t<composed_t<main()::__lambda0, int (*)(int)>, int (*)(int)>, int (*)(int)>]
     auto operator()(Ts&&... vs) -> decltype(l(std::forward<Ts>(vs)...))
          ^
main.cpp:39:10: note:   template argument deduction/substitution failed:
main.cpp: In substitution of 'template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<composed_t<composed_t<main()::__lambda0, int (*)(int)>, int (*)(int)>, int (*)(int)>] [with Ts = {int}]':
main.cpp:74:28:   required from here
main.cpp:39:10: error: no match for call to '(composed_t<composed_t<composed_t<main()::__lambda0, int (*)(int)>, int (*)(int)>, int (*)(int)>) (int)'
main.cpp:74:51: error: no match for call to '(composer<composed_t<main()::__lambda1, composer<composed_t<int (*)(int), composer<composed_t<int (*)(int), composer<int (*)(int)> > > > > > >) (int)'
     std::cout << comp1( 10 ) << "\n" << comp2( 10 ) << "\n";
                                                   ^
main.cpp:32:8: note: candidate is:
 struct composer{
        ^
main.cpp:39:10: note: template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<main()::__lambda1, composer<composed_t<int (*)(int), composer<composed_t<int (*)(int), composer<int (*)(int)> > > > > >]
     auto operator()(Ts&&... vs) -> decltype(l(std::forward<Ts>(vs)...))
          ^
main.cpp:39:10: note:   template argument deduction/substitution failed:
main.cpp: In substitution of 'template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<main()::__lambda1, composer<composed_t<int (*)(int), composer<composed_t<int (*)(int), composer<int (*)(int)> > > > > >] [with Ts = {int}]':
main.cpp:74:51:   required from here
main.cpp:39:10: error: no match for call to '(composed_t<main()::__lambda1, composer<composed_t<int (*)(int), composer<composed_t<int (*)(int), composer<int (*)(int)> > > > > >) (int)'
main.cpp:76:15: error: no match for call to '(composer<composed_t<void (*)(int), composer<void (*)()> > >) (int)'
     comp4( 10 );
               ^
main.cpp:32:8: note: candidate is:
 struct composer{
        ^
main.cpp:39:10: note: template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<void (*)(int), composer<void (*)()> >]
     auto operator()(Ts&&... vs) -> decltype(l(std::forward<Ts>(vs)...))
          ^
main.cpp:39:10: note:   template argument deduction/substitution failed:
main.cpp: In substitution of 'template<class ... Ts> decltype (((composer<L>*)this)->composer<L>::l((forward<Ts>)(composer::operator()::vs)...)) composer<L>::operator()(Ts&& ...) [with Ts = {Ts ...}; L = composed_t<void (*)(int), composer<void (*)()> >] [with Ts = {int}]':
main.cpp:76:15:   required from here
main.cpp:39:10: error: no match for call to '(composed_t<void (*)(int), composer<void (*)()> >) (int)'
