In file included from main.cpp:2:0:
/usr/local/include/boost/multiprecision/cpp_dec_float.hpp: In instantiation of 'static uint32_t boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_uv(uint32_t*, const uint32_t*, int32_t) [with unsigned int Digits10 = 100000u; ExponentType = int; Allocator = void; uint32_t = unsigned int; int32_t = int]':
/usr/local/include/boost/multiprecision/cpp_dec_float.hpp:922:82:   required from 'boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>& boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>::operator*=(const boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>&) [with unsigned int Digits10 = 100000u; ExponentType = int; Allocator = void]'
/usr/local/include/boost/multiprecision/cpp_dec_float.hpp:2246:7:   required from 'boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>& boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>::operator=(long double) [with unsigned int Digits10 = 100000u; ExponentType = int; Allocator = void]'
/usr/local/include/boost/multiprecision/cpp_dec_float.hpp:262:7:   required from 'boost::multiprecision::backends::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float(F, typename boost::enable_if<boost::is_floating_point<F> >::type*) [with F = long double; unsigned int Digits10 = 100000u; ExponentType = int; Allocator = void; typename boost::enable_if<boost::is_floating_point<F> >::type = void]'
/usr/local/include/boost/multiprecision/number.hpp:59:37:   required from 'constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename boost::enable_if_c<(boost::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type*) [with V = long double; Backend = boost::multiprecision::backends::cpp_dec_float<100000u>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u; typename boost::enable_if_c<(boost::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type = void]'
/usr/local/include/boost/type_traits/is_convertible.hpp:143:49:   required from 'const bool boost::detail::is_convertible_basic_impl<long double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> > >::value'
/usr/local/include/boost/type_traits/is_convertible.hpp:354:5:   [ skipping 2 instantiation contexts ]
/usr/local/include/boost/mpl/aux_/nested_type_wknd.hpp:26:31:   required from 'struct boost::mpl::aux::nested_type_wknd<boost::is_convertible<long double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> > > >'
/usr/local/include/boost/mpl/aux_/preprocessed/gcc/and.hpp:48:8:   required from 'struct boost::mpl::and_<boost::is_convertible<long double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> > >, mpl_::bool_<false>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >'
/usr/local/include/boost/mpl/if.hpp:67:11:   required from 'struct boost::mpl::if_<boost::mpl::and_<boost::is_convertible<long double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> > >, mpl_::bool_<false>, mpl_::bool_<true>, mpl_::bool_<true>, mpl_::bool_<true> >, mpl_::int_<3>, mpl_::int_<332229> >'
/usr/local/include/boost/math/constants/constants.hpp:223:3:   recursively required from 'constexpr T boost::math::constants::pi() [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> >; Policy = boost::math::policies::policy<boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy, boost::math::policies::default_policy>]'
/usr/local/include/boost/math/constants/constants.hpp:223:3:   required from 'constexpr T boost::math::constants::pi() [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100000u> >]'
main.cpp:12:41:   required from here
/usr/local/include/boost/multiprecision/cpp_dec_float.hpp:2299:4: error: static assertion failed: Too many limbs in the data type for the multiplication algorithm - unsupported precision in cpp_dec_float.
