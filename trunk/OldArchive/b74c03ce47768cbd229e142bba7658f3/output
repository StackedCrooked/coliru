In file included from /usr/include/c++/4.7/mutex:43:0,
                 from /usr/include/c++/4.7/condition_variable:39,
                 from main.cpp:3:
/usr/include/c++/4.7/functional: In instantiation of 'struct std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>':
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:94:68:   required from here
/usr/include/c++/4.7/functional:1199:7: error: 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(const std::_Bind<_Functor(_Bound_args ...)>&) [with _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}; std::_Bind<_Functor(_Bound_args ...)> = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]' declared to take const reference, but implicit declaration would take non-const
/usr/include/c++/4.7/functional: In instantiation of 'struct std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>':
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:95:68:   required from here
/usr/include/c++/4.7/functional:1199:7: error: 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(const std::_Bind<_Functor(_Bound_args ...)>&) [with _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}; std::_Bind<_Functor(_Bound_args ...)> = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]' declared to take const reference, but implicit declaration would take non-const
/usr/include/c++/4.7/functional: In instantiation of 'struct std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>':
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:96:68:   required from here
/usr/include/c++/4.7/functional:1199:7: error: 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(const std::_Bind<_Functor(_Bound_args ...)>&) [with _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}; std::_Bind<_Functor(_Bound_args ...)> = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]' declared to take const reference, but implicit declaration would take non-const
/usr/include/c++/4.7/functional: In instantiation of 'struct std::_Bind<Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>()>':
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]'
main.cpp:31:9:   required from 'Shared<T>::~Shared() [with T = Car]'
main.cpp:93:17:   required from here
/usr/include/c++/4.7/functional:1199:7: error: 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(const std::_Bind<_Functor(_Bound_args ...)>&) [with _Functor = Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>; _Bound_args = {}; std::_Bind<_Functor(_Bound_args ...)> = std::_Bind<Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>()>]' declared to take const reference, but implicit declaration would take non-const
/usr/include/c++/4.7/functional: In instantiation of 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(_Functor&&, _Args&& ...) [with _Args = {}; _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}]':
/usr/include/c++/4.7/functional:1527:42:   required from 'typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type std::bind(_Func&&, _BoundArgs&& ...) [with _Func = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _BoundArgs = {}; typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]'
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:94:68:   required from here
/usr/include/c++/4.7/functional:1196:70: error: no matching function for call to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::__lambda5(std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type)'
/usr/include/c++/4.7/functional:1196:70: note: candidate is:
main.cpp:41:33: note: Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::<lambda>(Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&)
main.cpp:41:33: note:   no known conversion for argument 1 from 'std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type {aka Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>}' to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&'
In file included from /usr/include/c++/4.7/mutex:43:0,
                 from /usr/include/c++/4.7/condition_variable:39,
                 from main.cpp:3:
/usr/include/c++/4.7/functional: In instantiation of 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(_Functor&&, _Args&& ...) [with _Args = {}; _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}]':
/usr/include/c++/4.7/functional:1527:42:   required from 'typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type std::bind(_Func&&, _BoundArgs&& ...) [with _Func = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _BoundArgs = {}; typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]'
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:95:68:   required from here
/usr/include/c++/4.7/functional:1196:70: error: no matching function for call to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::__lambda5(std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type)'
/usr/include/c++/4.7/functional:1196:70: note: candidate is:
main.cpp:41:33: note: Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::<lambda>(Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&)
main.cpp:41:33: note:   no known conversion for argument 1 from 'std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type {aka Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>}' to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&'
In file included from /usr/include/c++/4.7/mutex:43:0,
                 from /usr/include/c++/4.7/condition_variable:39,
                 from main.cpp:3:
/usr/include/c++/4.7/functional: In instantiation of 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(_Functor&&, _Args&& ...) [with _Args = {}; _Functor = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _Bound_args = {}]':
/usr/include/c++/4.7/functional:1527:42:   required from 'typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type std::bind(_Func&&, _BoundArgs&& ...) [with _Func = Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>; _BoundArgs = {}; typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type = std::_Bind<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>()>]'
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]'
main.cpp:96:68:   required from here
/usr/include/c++/4.7/functional:1196:70: error: no matching function for call to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::__lambda5(std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type)'
/usr/include/c++/4.7/functional:1196:70: note: candidate is:
main.cpp:41:33: note: Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>::<lambda>(Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&)
main.cpp:41:33: note:   no known conversion for argument 1 from 'std::remove_reference<Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&>::type {aka Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>}' to 'Shared<T>::execute(F) [with F = main()::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = unsigned int]::<lambda()>&'
In file included from /usr/include/c++/4.7/mutex:43:0,
                 from /usr/include/c++/4.7/condition_variable:39,
                 from main.cpp:3:
/usr/include/c++/4.7/functional: In instantiation of 'std::_Bind<_Functor(_Bound_args ...)>::_Bind(_Functor&&, _Args&& ...) [with _Args = {}; _Functor = Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>; _Bound_args = {}]':
/usr/include/c++/4.7/functional:1527:42:   required from 'typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type std::bind(_Func&&, _BoundArgs&& ...) [with _Func = Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>; _BoundArgs = {}; typename std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type = std::_Bind<Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>()>]'
main.cpp:41:9:   required from 'std::future<typename std::result_of<F(T&)>::type> Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]'
main.cpp:31:9:   required from 'Shared<T>::~Shared() [with T = Car]'
main.cpp:93:17:   required from here
/usr/include/c++/4.7/functional:1196:70: error: no matching function for call to 'Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>::__lambda5(std::remove_reference<Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>&>::type)'
/usr/include/c++/4.7/functional:1196:70: note: candidate is:
main.cpp:41:33: note: Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>::<lambda>(Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>&)
main.cpp:41:33: note:   no known conversion for argument 1 from 'std::remove_reference<Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>&>::type {aka Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>}' to 'Shared<T>::execute(F) [with F = Shared<T>::~Shared() [with T = Car]::<lambda(Car&)>; T = Car; typename std::result_of<F(T&)>::type = int]::<lambda()>&'
