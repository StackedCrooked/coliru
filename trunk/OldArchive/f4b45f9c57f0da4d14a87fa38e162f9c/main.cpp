/**
 * Problem 12
 * ----------
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
 * first ten terms would be:
 *   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *   10: 1,2,5,10
 *   15: 1,3,5,15
 *   21: 1,3,7,21
 *   28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */


#include <algorithm>
#include <iostream>
#include <map>
#include <vector>
#include <stdint.h>



typedef std::map<unsigned, unsigned> Map;
Map get_prime_factors(unsigned n);


template<typename T>
std::ostream& operator<<(std::ostream & os, const std::vector<T> & vec)
{
    os << "{ ";
    for (const auto & v : vec)
    {
        os << v << " ";
    }
    return os << "}";
}

template<typename T>
std::ostream& operator<<(std::ostream & os, const std::map<T, T> & vec)
{
    unsigned c = 0;
    for (const auto & p : vec)
    {
        if (c++)
        {
            os << '*';
        }
        for (unsigned i = 0; i < p.second; ++i)
        {
            if (i != 0)
            {
                os << '*';
            }
            os << p.first;
        }
    }
    return os;
}


bool is_prime(uint64_t n, const std::vector<uint64_t> & preceding)
{
    // precondition: "preceding" contains all primes < sqrt(n)

    for (auto p : preceding)
    {
        if ((p * p) > n)
        {
            return true;
        }

        if (n % p == 0)
        {
            return false;
        }
    }
    return true;
}


uint64_t next_prime(const std::vector<uint64_t> & preceding)
{
    if (preceding.empty())
    {
        return 2;
    }

    if (preceding.back() == 2)
    {
        return 3;
    }

    for (uint64_t n = preceding.back() + 2; ; n += 2)
    {
        if (is_prime(n, preceding))
        {
            return n;
        }
    }
}


unsigned num_divisors(unsigned n)
{
    unsigned result = 1;
    for (auto pair : get_prime_factors(n))
    {
        result *= (pair.second + 1);
    }
    return result;
}


unsigned triangle(unsigned n)
{
    return n % 2 == 0 ? (n/2) * (n+1) : ((n+1)/2) * n;
}



Map operator+(Map lhs, const Map & rhs)
{
    for (auto p : rhs)
    {
        lhs[p.first] += p.second;
    }
    return lhs;
}


Map get_prime_factors(unsigned n)
{
    static std::map<unsigned, Map> cache;
    auto it = cache.find(n);
    if (it != cache.end())
    {
        return it->second;
    }
        
    std::map<unsigned, unsigned> & result = cache[n];
    std::vector<uint64_t> pre = {2};
    for (unsigned i = 2; i <= n; i = next_prime(pre))
    {
        pre.push_back(i);
        auto copy = n;
        while (copy % i == 0)
        {
            result[i]++;
            copy /= i;
        }
    }
    return result;
}


Map get_prime_factors_of_tr(unsigned n)
{
    static std::map<unsigned, Map> cache;
    auto it = cache.find(n);
    if (it != cache.end())
    {
        return it->second;
    }
    
    std::map<unsigned, unsigned> & result = cache[n];
    if (n%2 ==0)
    {
        result = get_prime_factors(n/2) + get_prime_factors(n + 1);
        return result;
    }
    else
    {
        result = get_prime_factors(n) + get_prime_factors((n + 1)/2);
        return result;
    }
}


int main()
{
    std::cout << "i	tr(i)	prime factors" << std::endl;
    for (unsigned i = 0; i <= 500; ++i)
    {
        auto tr = triangle(i);
        std::cout << i << ": " << tr << " -> " << get_prime_factors_of_tr(tr) << std::endl;
    }
}
