+ g++ -std=c++11 -O2 -Wall -pedantic -pthread main.cpp
main.cpp: In function ‘int main()’:
main.cpp:19:9: error: no match for call to ‘(std::_Bind<std::_Mem_fn<void (something::*)(int)>(something*)>) (int)’
     f(42);
         ^
In file included from main.cpp:4:0:
/usr/include/c++/4.8/functional:1280:11: note: candidates are:
     class _Bind<_Functor(_Bound_args...)>
           ^
/usr/include/c++/4.8/functional:1351:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) [with _Args = {_Args ...}; _Result = _Result; _Functor = std::_Mem_fn<void (something::*)(int)>; _Bound_args = {something*}]
  operator()(_Args&&... __args)
  ^
/usr/include/c++/4.8/functional:1351:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1347:37: error: no match for call to ‘(std::_Mem_fn<void (something::*)(int)>) (something*&)’
  = decltype( std::declval<_Functor>()(
                                     ^
/usr/include/c++/4.8/functional:541:11: note: candidates are:
     class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
           ^
/usr/include/c++/4.8/functional:587:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:587:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1347:37: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something*&, std::tuple<int> >((* & std::declval<something*&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something*’) to type ‘something&’
  = decltype( std::declval<_Functor>()(
                                     ^
/usr/include/c++/4.8/functional:592:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:592:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1347:37: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something*&, std::tuple<int> >((* & std::declval<something*&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something*’) to type ‘something&&’
  = decltype( std::declval<_Functor>()(
                                     ^
/usr/include/c++/4.8/functional:600:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class*, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class* __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:600:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:607:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Tp&&, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Tp&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:607:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:616:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(std::reference_wrapper<_Tp>, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:616:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1347:37: note:   mismatched types ‘std::reference_wrapper<_Tp>’ and ‘something*’
  = decltype( std::declval<_Functor>()(
                                     ^
/usr/include/c++/4.8/functional:1365:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const [with _Args = {_Args ...}; _Result = _Result; _Functor = std::_Mem_fn<void (something::*)(int)>; _Bound_args = {something*}]
  operator()(_Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:1365:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1361:53: error: no match for call to ‘(const std::_Mem_fn<void (something::*)(int)>) (something* const&)’
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/include/c++/4.8/functional:541:11: note: candidates are:
     class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
           ^
/usr/include/c++/4.8/functional:587:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:587:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1361:53: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* const&, std::tuple<int> >((* & std::declval<something* const&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* const’) to type ‘something&’
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/include/c++/4.8/functional:592:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:592:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1361:53: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* const&, std::tuple<int> >((* & std::declval<something* const&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* const’) to type ‘something&&’
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/include/c++/4.8/functional:600:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class*, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class* __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:600:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:607:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Tp&&, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Tp&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:607:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:616:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(std::reference_wrapper<_Tp>, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:616:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1361:53: note:   mismatched types ‘std::reference_wrapper<_Tp>’ and ‘something*’
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/include/c++/4.8/functional:1379:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = std::_Mem_fn<void (something::*)(int)>; _Bound_args = {something*}]
  operator()(_Args&&... __args) volatile
  ^
/usr/include/c++/4.8/functional:1379:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1375:70: error: no match for call to ‘(volatile std::_Mem_fn<void (something::*)(int)>) (something* volatile&)’
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/include/c++/4.8/functional:541:11: note: candidates are:
     class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
           ^
/usr/include/c++/4.8/functional:587:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:587:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1375:70: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* volatile&, std::tuple<int> >((* & std::declval<something* volatile&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* volatile’) to type ‘something&’
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/include/c++/4.8/functional:592:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:592:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1375:70: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* volatile&, std::tuple<int> >((* & std::declval<something* volatile&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* volatile’) to type ‘something&&’
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/include/c++/4.8/functional:600:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class*, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class* __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:600:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:607:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Tp&&, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Tp&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:607:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:616:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(std::reference_wrapper<_Tp>, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:616:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1375:70: note:   mismatched types ‘std::reference_wrapper<_Tp>’ and ‘something*’
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/include/c++/4.8/functional:1393:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = std::_Mem_fn<void (something::*)(int)>; _Bound_args = {something*}]
  operator()(_Args&&... __args) const volatile
  ^
/usr/include/c++/4.8/functional:1393:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1389:64: error: no match for call to ‘(const volatile std::_Mem_fn<void (something::*)(int)>) (something* const volatile&)’
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
/usr/include/c++/4.8/functional:541:11: note: candidates are:
     class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
           ^
/usr/include/c++/4.8/functional:587:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:587:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1389:64: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* const volatile&, std::tuple<int> >((* & std::declval<something* const volatile&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* const volatile’) to type ‘something&’
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
/usr/include/c++/4.8/functional:592:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class&&, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:592:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1389:64: note:   cannot convert ‘std::_Mu<something*, false, false>().std::_Mu<_Arg, false, false>::operator()<something* const volatile&, std::tuple<int> >((* & std::declval<something* const volatile&>()), (* & std::declval<std::tuple<int>&>()))’ (type ‘something* const volatile’) to type ‘something&&’
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
/usr/include/c++/4.8/functional:600:2: note: template<class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Class*, _Args&& ...) const [with _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Class* __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:600:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:607:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(_Tp&&, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(_Tp&& __object, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:607:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:616:2: note: template<class _Tp, class ... _Args, class _Req> _Res std::_Mem_fn<_Res (_Class::*)(_ArgTypes ...)>::operator()(std::reference_wrapper<_Tp>, _Args&& ...) const [with _Tp = _Tp; _Args = {_Args ...}; _Req = _Req; _Res = void; _Class = something; _ArgTypes = {int}]
  operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:616:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1389:64: note:   mismatched types ‘std::reference_wrapper<_Tp>’ and ‘something*’
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
