main.cpp:213:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:216:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:219:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:222:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:225:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:228:13: warning: unused parameter 'sig' [-Wunused-parameter]
main.cpp:228:13: warning: unused parameter 'si' [-Wunused-parameter]
main.cpp:228:13: warning: unused parameter 'unused' [-Wunused-parameter]
std::thread::hardware_concurrency() = 1
default value:
    corePoolSize = 1, maximumPoolSize = 1, keepAliveTime = 300000 ms.
new value:
    corePoolSize = 4, maximumPoolSize = 8, keepAliveTime = 2000 ms.
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
2外
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3外
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3.    conditionVariable_.wait(lk);→exit.
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4外
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
notify.
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
3.    conditionVariable_.wait(lk);→exit.
23内
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4.    conditionVariable_.wait(lk);→exit.
4.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5外
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
notify.
3.    conditionVariable_.wait(lk);→exit.
3内
3内
notify.
3内
3内
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
6外
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.if (!enabled) {
45if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
.    conditionVariable_.wait(lk);→exit.
.    conditionVariable_.wait(lk);→exit.
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
45.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
notify.
3.    conditionVariable_.wait(lk);→exit.
3内
3内
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
notify.
notify.
notify.
notify.
notify.
notify.
退出.if (!enabled) {
2.    conditionVariable_.wait(lk);→exit.
2内
2内
6.    conditionVariable_.wait(lk);→exit.
6内
6内
6内
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.if (!enabled) {
7外
4退出.if (!enabled) {
3退出.if (!enabled) {
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
8外
notify.
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
notify.
6.    conditionVariable_.wait(lk);→exit.
6内
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
notify.
notify.
3.    conditionVariable_.wait(lk);→exit.
73.    conditionVariable_.wait(lk);→exit.
7内
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.if (!enabled) {
内
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3退出.if (!enabled) {
notify.
notify.
4notify.
6.    conditionVariable_.wait(lk);→exit.
6内
.    conditionVariable_.wait(lk);→exit.
654.    conditionVariable_.wait(lk);→exit.
.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
退出.ok.
notify.
notify.
notify.
notify.
notify.
notify.
7.    conditionVariable_.wait(lk);→exit.
7内
7内
7内
7内
7内
7内
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.if (!enabled) {
3.    conditionVariable_.wait(lk);→exit.
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3退出.ok.
5退出.if (!enabled) {
2.    conditionVariable_.wait(lk);→exit.
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.ok.
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
notify.
notify.
notify.
notify.
7.    conditionVariable_.wait(lk);→exit.
7内
7内
7内
7内
7内
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.if (!enabled) {
8.    conditionVariable_.wait(lk);→exit.
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
6.    conditionVariable_.wait(lk);→exit.
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
9外
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
10外
notify.
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
notify.
7.    conditionVariable_.wait(lk);→exit.
7内
7内
7内
7内
7内
7内
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.if (!enabled) {
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
8.    conditionVariable_.wait(lk);→exit.
8内
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
6.    conditionVariable_.wait(lk);→exit.
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.ok.
10.    conditionVariable_.wait(lk);→exit.
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
1110退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
8.    conditionVariable_.wait(lk);→exit.
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.ok.
7.    conditionVariable_.wait(lk);→exit.
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.ok.
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
notify.
notify.
notify.
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
10.    conditionVariable_.wait(lk);→exit.
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
10退出.ok.
9if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {.    conditionVariable_.wait(lk);→exit.

9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.if (!enabled) {
12外
notify.
13外
notify.
外
notify.
notify.
notify.
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
5.    conditionVariable_.wait(lk);→exit.
514内
外
5内
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
9.    conditionVariable_.wait(lk);→exit.
9内
9内
9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.if (!enabled) {
12.    conditionVariable_.wait(lk);→exit.
12.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
12退出.if (!enabled) {
notify.
notify.
14notify.
.    conditionVariable_.wait(lk);→exit.
14内
14内
14内
14.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
14退出.if (!enabled) {
notify.
notify.
notify.
notify.
9.    conditionVariable_.wait(lk);→exit.
9内
9内
9内
9内
9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.if (!enabled) {
12.    conditionVariable_.wait(lk);→exit.
12.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
12退出.ok.
13notify.
.    conditionVariable_.wait(lk);→exit.
13内
13.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
13退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
notify.
15if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
13.    conditionVariable_.wait(lk);→exit.
13.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
13退出.ok.
if (PoolSize_ < maximumPoolSize_ && taskQueueSize_ + 1 > PoolSize_) {
16notify.
notify.
notify.
notify.
notify.
notify.
145.    conditionVariable_.wait(lk);→exit.
.    conditionVariable_.wait(lk);→exit.
5内
14内
5内
145内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
内
14.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
14退出.if (!enabled) {
外
11.    conditionVariable_.wait(lk);→exit.
11.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
11退出.if (!enabled) {
9外
.    conditionVariable_.wait(lk);→exit.
9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.ok.
17外
14.    conditionVariable_.wait(lk);→exit.
14.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
14退出.ok.
11.    conditionVariable_.wait(lk);→exit.
11.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
11退出.ok.
5.    conditionVariable_.wait(lk);→exit.
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
Cleanup().
155.    conditionVariable_.wait(lk);→exit.
.    conditionVariable_.wait(lk);→exit.
16.    conditionVariable_.wait(lk);→exit.
17.    conditionVariable_.wait(lk);→exit.
cnt = 4950
