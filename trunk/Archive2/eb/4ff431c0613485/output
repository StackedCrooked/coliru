In file included from main.cpp:4:0:
variant.hpp: In instantiation of 'insituc::variant<types>::variant(rhs&&) [with rhs = main()::A; <template-parameter-2-2> = void; types = {main()::A, main()::B, main()::C, main()::D}]':
main.cpp:35:10:   required from here
variant.hpp:88:81: error: call of overloaded 'make_unique()' is ambiguous
     std::unique_ptr< storage_type > storage_ = std::make_unique< storage_type >();
                                                                                 ^
variant.hpp:88:81: note: candidates are:
In file included from /usr/local/include/c++/4.9.0/memory:81:0,
                 from variant_fwd.hpp:5,
                 from main.cpp:1:
/usr/local/include/c++/4.9.0/bits/unique_ptr.h:761:5: note: typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = std::aligned_storage<1ul, 1ul>::type; _Args = {}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<std::aligned_storage<1ul, 1ul>::type, std::default_delete<std::aligned_storage<1ul, 1ul>::type> >]
     make_unique(_Args&&... __args)
     ^
In file included from main.cpp:1:0:
variant_fwd.hpp:12:1: note: std::unique_ptr<_Tp> std::make_unique(Args&& ...) [with T = std::aligned_storage<1ul, 1ul>::type; Args = {}]
 make_unique(Args &&... _args)
 ^
In file included from main.cpp:4:0:
variant.hpp: In instantiation of 'insituc::variant<types>::variant(rhs&&) [with rhs = main()::B; <template-parameter-2-2> = void; types = {main()::A, main()::B, main()::C, main()::D}]':
main.cpp:35:19:   required from here
variant.hpp:88:81: error: call of overloaded 'make_unique()' is ambiguous
     std::unique_ptr< storage_type > storage_ = std::make_unique< storage_type >();
                                                                                 ^
variant.hpp:88:81: note: candidates are:
In file included from /usr/local/include/c++/4.9.0/memory:81:0,
                 from variant_fwd.hpp:5,
                 from main.cpp:1:
/usr/local/include/c++/4.9.0/bits/unique_ptr.h:761:5: note: typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = std::aligned_storage<1ul, 1ul>::type; _Args = {}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<std::aligned_storage<1ul, 1ul>::type, std::default_delete<std::aligned_storage<1ul, 1ul>::type> >]
     make_unique(_Args&&... __args)
     ^
In file included from main.cpp:1:0:
variant_fwd.hpp:12:1: note: std::unique_ptr<_Tp> std::make_unique(Args&& ...) [with T = std::aligned_storage<1ul, 1ul>::type; Args = {}]
 make_unique(Args &&... _args)
 ^
In file included from main.cpp:4:0:
variant.hpp: In instantiation of 'insituc::variant<types>::variant(rhs&&) [with rhs = main()::C; <template-parameter-2-2> = void; types = {main()::A, main()::B, main()::C, main()::D}]':
main.cpp:35:28:   required from here
variant.hpp:88:81: error: call of overloaded 'make_unique()' is ambiguous
     std::unique_ptr< storage_type > storage_ = std::make_unique< storage_type >();
                                                                                 ^
variant.hpp:88:81: note: candidates are:
In file included from /usr/local/include/c++/4.9.0/memory:81:0,
                 from variant_fwd.hpp:5,
                 from main.cpp:1:
/usr/local/include/c++/4.9.0/bits/unique_ptr.h:761:5: note: typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = std::aligned_storage<1ul, 1ul>::type; _Args = {}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<std::aligned_storage<1ul, 1ul>::type, std::default_delete<std::aligned_storage<1ul, 1ul>::type> >]
     make_unique(_Args&&... __args)
     ^
In file included from main.cpp:1:0:
variant_fwd.hpp:12:1: note: std::unique_ptr<_Tp> std::make_unique(Args&& ...) [with T = std::aligned_storage<1ul, 1ul>::type; Args = {}]
 make_unique(Args &&... _args)
 ^
In file included from main.cpp:4:0:
variant.hpp: In instantiation of 'insituc::variant<types>::variant(rhs&&) [with rhs = main()::D; <template-parameter-2-2> = void; types = {main()::A, main()::B, main()::C, main()::D}]':
main.cpp:35:37:   required from here
variant.hpp:88:81: error: call of overloaded 'make_unique()' is ambiguous
     std::unique_ptr< storage_type > storage_ = std::make_unique< storage_type >();
                                                                                 ^
variant.hpp:88:81: note: candidates are:
In file included from /usr/local/include/c++/4.9.0/memory:81:0,
                 from variant_fwd.hpp:5,
                 from main.cpp:1:
/usr/local/include/c++/4.9.0/bits/unique_ptr.h:761:5: note: typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = std::aligned_storage<1ul, 1ul>::type; _Args = {}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<std::aligned_storage<1ul, 1ul>::type, std::default_delete<std::aligned_storage<1ul, 1ul>::type> >]
     make_unique(_Args&&... __args)
     ^
In file included from main.cpp:1:0:
variant_fwd.hpp:12:1: note: std::unique_ptr<_Tp> std::make_unique(Args&& ...) [with T = std::aligned_storage<1ul, 1ul>::type; Args = {}]
 make_unique(Args &&... _args)
 ^
In file included from main.cpp:4:0:
variant.hpp:127:5: error: 'insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> insituc::variant<types>::construct(rhs&&) [with rhs = main()::A; types = {main()::A, main()::B, main()::C, main()::D}; insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> = void]', declared using local type 'main()::A', is used but never defined [-fpermissive]
     construct(rhs && _rhs)
     ^
variant.hpp:127:5: error: 'insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> insituc::variant<types>::construct(rhs&&) [with rhs = main()::B; types = {main()::A, main()::B, main()::C, main()::D}; insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> = void]', declared using local type 'main()::B', is used but never defined [-fpermissive]
variant.hpp:127:5: error: 'insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> insituc::variant<types>::construct(rhs&&) [with rhs = main()::C; types = {main()::A, main()::B, main()::C, main()::D}; insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> = void]', declared using local type 'main()::C', is used but never defined [-fpermissive]
variant.hpp:127:5: error: 'insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> insituc::variant<types>::construct(rhs&&) [with rhs = main()::D; types = {main()::A, main()::B, main()::C, main()::D}; insituc::enable_if<typename std::integral_constant<bool, (!(insituc::get_offset<0, insituc::is_same<typename std::remove_cv<typename std::remove_reference<typename std::remove_cv<typename std::remove_reference<type>::type>::type>::type>::type, typename insituc::details::unwrap_type<types>::type>::value ...>::value < 0))>::type:: value> = void]', declared using local type 'main()::D', is used but never defined [-fpermissive]

real	0m9.700s
user	0m4.008s
sys	0m0.736s
