; ModuleID = 'main.cpp'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind readnone uwtable
define i32 @_Z9factoriali(i32 %n) #0 {
  %1 = icmp slt i32 %n, 2
  br i1 %1, label %tailrecurse._crit_edge, label %tailrecurse.preheader

tailrecurse.preheader:                            ; preds = %0
  %2 = xor i32 %n, -1
  %3 = icmp sgt i32 %2, -3
  %smax = select i1 %3, i32 %2, i32 -3
  %4 = add i32 %smax, %n
  %backedge.overflow = icmp eq i32 %4, -2
  br i1 %backedge.overflow, label %tailrecurse.preheader9, label %overflow.checked

overflow.checked:                                 ; preds = %tailrecurse.preheader
  %5 = add i32 %4, 2
  %end.idx = add i32 %4, 2
  %n.vec = and i32 %5, -8
  %cmp.zero = icmp eq i32 %n.vec, 0
  %rev.ind.end = sub i32 %n, %n.vec
  br i1 %cmp.zero, label %middle.block, label %vector.body.preheader

vector.body.preheader:                            ; preds = %overflow.checked
  %6 = sub i32 -1, %n
  %7 = icmp sgt i32 %6, -3
  %smax21 = select i1 %7, i32 %6, i32 -3
  %8 = add i32 %n, %smax21
  %9 = add i32 %8, 2
  %10 = lshr i32 %9, 3
  %11 = mul i32 %10, 8
  %12 = add i32 %11, -8
  %13 = lshr i32 %12, 3
  %14 = add i32 %13, 1
  %xtraiter22 = and i32 %14, 1
  %lcmp.mod23 = icmp ne i32 %xtraiter22, 0
  %lcmp.overflow24 = icmp eq i32 %14, 0
  %lcmp.or25 = or i1 %lcmp.overflow24, %lcmp.mod23
  br i1 %lcmp.or25, label %vector.body.unr, label %vector.body.preheader.split

vector.body.unr:                                  ; preds = %vector.body.preheader
  %reverse.idx.unr = sub i32 %n, 0
  %broadcast.splatinsert.unr = insertelement <4 x i32> undef, i32 %reverse.idx.unr, i32 0
  %broadcast.splat.unr = shufflevector <4 x i32> %broadcast.splatinsert.unr, <4 x i32> undef, <4 x i32> zeroinitializer
  %induction.unr = add <4 x i32> %broadcast.splat.unr, <i32 0, i32 -1, i32 -2, i32 -3>
  %induction3.unr = add <4 x i32> %broadcast.splat.unr, <i32 -4, i32 -5, i32 -6, i32 -7>
  %15 = mul nsw <4 x i32> %induction.unr, <i32 1, i32 1, i32 1, i32 1>
  %16 = mul nsw <4 x i32> %induction3.unr, <i32 1, i32 1, i32 1, i32 1>
  %index.next.unr = add i32 0, 8
  %17 = icmp eq i32 %index.next.unr, %n.vec
  br label %vector.body.preheader.split

vector.body.preheader.split:                      ; preds = %vector.body.unr, %vector.body.preheader
  %.lcssa11.unr = phi <4 x i32> [ zeroinitializer, %vector.body.preheader ], [ %16, %vector.body.unr ]
  %.lcssa10.unr = phi <4 x i32> [ zeroinitializer, %vector.body.preheader ], [ %15, %vector.body.unr ]
  %index.unr = phi i32 [ 0, %vector.body.preheader ], [ %index.next.unr, %vector.body.unr ]
  %vec.phi.unr = phi <4 x i32> [ <i32 1, i32 1, i32 1, i32 1>, %vector.body.preheader ], [ %15, %vector.body.unr ]
  %vec.phi4.unr = phi <4 x i32> [ <i32 1, i32 1, i32 1, i32 1>, %vector.body.preheader ], [ %16, %vector.body.unr ]
  %18 = icmp ult i32 %14, 2
  br i1 %18, label %middle.block.loopexit, label %vector.body.preheader.split.split

vector.body.preheader.split.split:                ; preds = %vector.body.preheader.split
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.body.preheader.split.split
  %index = phi i32 [ %index.unr, %vector.body.preheader.split.split ], [ %index.next.1, %vector.body ]
  %vec.phi = phi <4 x i32> [ %vec.phi.unr, %vector.body.preheader.split.split ], [ %21, %vector.body ]
  %vec.phi4 = phi <4 x i32> [ %vec.phi4.unr, %vector.body.preheader.split.split ], [ %22, %vector.body ]
  %reverse.idx = sub i32 %n, %index
  %broadcast.splatinsert = insertelement <4 x i32> undef, i32 %reverse.idx, i32 0
  %broadcast.splat = shufflevector <4 x i32> %broadcast.splatinsert, <4 x i32> undef, <4 x i32> zeroinitializer
  %induction = add <4 x i32> %broadcast.splat, <i32 0, i32 -1, i32 -2, i32 -3>
  %induction3 = add <4 x i32> %broadcast.splat, <i32 -4, i32 -5, i32 -6, i32 -7>
  %19 = mul nsw <4 x i32> %induction, %vec.phi
  %20 = mul nsw <4 x i32> %induction3, %vec.phi4
  %index.next = add i32 %index, 8
  %reverse.idx.1 = sub i32 %n, %index.next
  %broadcast.splatinsert.1 = insertelement <4 x i32> undef, i32 %reverse.idx.1, i32 0
  %broadcast.splat.1 = shufflevector <4 x i32> %broadcast.splatinsert.1, <4 x i32> undef, <4 x i32> zeroinitializer
  %induction.1 = add <4 x i32> %broadcast.splat.1, <i32 0, i32 -1, i32 -2, i32 -3>
  %induction3.1 = add <4 x i32> %broadcast.splat.1, <i32 -4, i32 -5, i32 -6, i32 -7>
  %21 = mul nsw <4 x i32> %induction.1, %19
  %22 = mul nsw <4 x i32> %induction3.1, %20
  %index.next.1 = add i32 %index.next, 8
  %23 = icmp eq i32 %index.next.1, %n.vec
  br i1 %23, label %middle.block.loopexit.unr-lcssa, label %vector.body, !llvm.loop !1

middle.block.loopexit.unr-lcssa:                  ; preds = %vector.body
  %.lcssa11.ph = phi <4 x i32> [ %22, %vector.body ]
  %.lcssa10.ph = phi <4 x i32> [ %21, %vector.body ]
  br label %middle.block.loopexit

middle.block.loopexit:                            ; preds = %vector.body.preheader.split, %middle.block.loopexit.unr-lcssa
  %.lcssa11 = phi <4 x i32> [ %.lcssa11.unr, %vector.body.preheader.split ], [ %.lcssa11.ph, %middle.block.loopexit.unr-lcssa ]
  %.lcssa10 = phi <4 x i32> [ %.lcssa10.unr, %vector.body.preheader.split ], [ %.lcssa10.ph, %middle.block.loopexit.unr-lcssa ]
  br label %middle.block

middle.block:                                     ; preds = %middle.block.loopexit, %overflow.checked
  %resume.val = phi i32 [ %n, %overflow.checked ], [ %rev.ind.end, %middle.block.loopexit ]
  %new.indc.resume.val = phi i32 [ 0, %overflow.checked ], [ %n.vec, %middle.block.loopexit ]
  %rdx.vec.exit.phi = phi <4 x i32> [ <i32 1, i32 1, i32 1, i32 1>, %overflow.checked ], [ %.lcssa10, %middle.block.loopexit ]
  %rdx.vec.exit.phi5 = phi <4 x i32> [ <i32 1, i32 1, i32 1, i32 1>, %overflow.checked ], [ %.lcssa11, %middle.block.loopexit ]
  %bin.rdx = mul <4 x i32> %rdx.vec.exit.phi5, %rdx.vec.exit.phi
  %rdx.shuf = shufflevector <4 x i32> %bin.rdx, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %bin.rdx6 = mul <4 x i32> %bin.rdx, %rdx.shuf
  %rdx.shuf7 = shufflevector <4 x i32> %bin.rdx6, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %bin.rdx8 = mul <4 x i32> %bin.rdx6, %rdx.shuf7
  %24 = extractelement <4 x i32> %bin.rdx8, i32 0
  %cmp.n = icmp eq i32 %end.idx, %new.indc.resume.val
  br i1 %cmp.n, label %tailrecurse._crit_edge, label %tailrecurse.preheader9

tailrecurse.preheader9:                           ; preds = %middle.block, %tailrecurse.preheader
  %n.tr2.ph = phi i32 [ %n, %tailrecurse.preheader ], [ %resume.val, %middle.block ]
  %accumulator.tr1.ph = phi i32 [ 1, %tailrecurse.preheader ], [ %24, %middle.block ]
  %25 = sub i32 -1, %n.tr2.ph
  %26 = icmp sgt i32 %25, -3
  %smax12 = select i1 %26, i32 %25, i32 -3
  %27 = add i32 %n.tr2.ph, %smax12
  %28 = add i32 %27, 2
  %xtraiter = and i32 %28, 3
  %lcmp.mod = icmp ne i32 %xtraiter, 0
  %lcmp.overflow = icmp eq i32 %28, 0
  %lcmp.or = or i1 %lcmp.overflow, %lcmp.mod
  br i1 %lcmp.or, label %unr.cmp17, label %tailrecurse.preheader9.split

unr.cmp17:                                        ; preds = %tailrecurse.preheader9
  %un.tmp18 = icmp eq i32 %xtraiter, 1
  br i1 %un.tmp18, label %tailrecurse.unr14, label %unr.cmp

unr.cmp:                                          ; preds = %unr.cmp17
  %un.tmp = icmp eq i32 %xtraiter, 2
  br i1 %un.tmp, label %tailrecurse.unr13, label %tailrecurse.unr

tailrecurse.unr:                                  ; preds = %unr.cmp
  %29 = add nsw i32 %n.tr2.ph, -1
  %30 = mul nsw i32 %n.tr2.ph, %accumulator.tr1.ph
  %31 = icmp slt i32 %n.tr2.ph, 3
  br label %tailrecurse.unr13

tailrecurse.unr13:                                ; preds = %unr.cmp, %tailrecurse.unr
  %n.tr2.unr = phi i32 [ %29, %tailrecurse.unr ], [ %n.tr2.ph, %unr.cmp ]
  %accumulator.tr1.unr = phi i32 [ %30, %tailrecurse.unr ], [ %accumulator.tr1.ph, %unr.cmp ]
  %32 = add nsw i32 %n.tr2.unr, -1
  %33 = mul nsw i32 %n.tr2.unr, %accumulator.tr1.unr
  %34 = icmp slt i32 %n.tr2.unr, 3
  br label %tailrecurse.unr14

tailrecurse.unr14:                                ; preds = %unr.cmp17, %tailrecurse.unr13
  %n.tr2.unr15 = phi i32 [ %32, %tailrecurse.unr13 ], [ %n.tr2.ph, %unr.cmp17 ]
  %accumulator.tr1.unr16 = phi i32 [ %33, %tailrecurse.unr13 ], [ %accumulator.tr1.ph, %unr.cmp17 ]
  %35 = add nsw i32 %n.tr2.unr15, -1
  %36 = mul nsw i32 %n.tr2.unr15, %accumulator.tr1.unr16
  %37 = icmp slt i32 %n.tr2.unr15, 3
  br label %tailrecurse.preheader9.split

tailrecurse.preheader9.split:                     ; preds = %tailrecurse.unr14, %tailrecurse.preheader9
  %.lcssa.unr = phi i32 [ 0, %tailrecurse.preheader9 ], [ %36, %tailrecurse.unr14 ]
  %n.tr2.unr19 = phi i32 [ %n.tr2.ph, %tailrecurse.preheader9 ], [ %35, %tailrecurse.unr14 ]
  %accumulator.tr1.unr20 = phi i32 [ %accumulator.tr1.ph, %tailrecurse.preheader9 ], [ %36, %tailrecurse.unr14 ]
  %38 = icmp ult i32 %28, 4
  br i1 %38, label %tailrecurse._crit_edge.loopexit, label %tailrecurse.preheader9.split.split

tailrecurse.preheader9.split.split:               ; preds = %tailrecurse.preheader9.split
  br label %tailrecurse

tailrecurse:                                      ; preds = %tailrecurse, %tailrecurse.preheader9.split.split
  %n.tr2 = phi i32 [ %n.tr2.unr19, %tailrecurse.preheader9.split.split ], [ %45, %tailrecurse ]
  %accumulator.tr1 = phi i32 [ %accumulator.tr1.unr20, %tailrecurse.preheader9.split.split ], [ %46, %tailrecurse ]
  %39 = add nsw i32 %n.tr2, -1
  %40 = mul nsw i32 %n.tr2, %accumulator.tr1
  %41 = add nsw i32 %39, -1
  %42 = mul nsw i32 %39, %40
  %43 = add nsw i32 %41, -1
  %44 = mul nsw i32 %41, %42
  %45 = add nsw i32 %43, -1
  %46 = mul nsw i32 %43, %44
  %47 = icmp slt i32 %43, 3
  br i1 %47, label %tailrecurse._crit_edge.loopexit.unr-lcssa, label %tailrecurse, !llvm.loop !4

tailrecurse._crit_edge.loopexit.unr-lcssa:        ; preds = %tailrecurse
  %.lcssa.ph = phi i32 [ %46, %tailrecurse ]
  br label %tailrecurse._crit_edge.loopexit

tailrecurse._crit_edge.loopexit:                  ; preds = %tailrecurse.preheader9.split, %tailrecurse._crit_edge.loopexit.unr-lcssa
  %.lcssa = phi i32 [ %.lcssa.unr, %tailrecurse.preheader9.split ], [ %.lcssa.ph, %tailrecurse._crit_edge.loopexit.unr-lcssa ]
  br label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse._crit_edge.loopexit, %middle.block, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %24, %middle.block ], [ %.lcssa, %tailrecurse._crit_edge.loopexit ]
  ret i32 %accumulator.tr.lcssa
}

attributes #0 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5.0 (tags/RELEASE_350/final 217394)"}
!1 = metadata !{metadata !1, metadata !2, metadata !3}
!2 = metadata !{metadata !"llvm.loop.vectorize.width", i32 1}
!3 = metadata !{metadata !"llvm.loop.interleave.count", i32 1}
!4 = metadata !{metadata !4, metadata !2, metadata !3}
