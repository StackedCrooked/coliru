In file included from main.cpp:3:0:
/usr/local/include/boost/msm/back/state_machine.hpp: In instantiation of 'static typename boost::disable_if<typename boost::mpl::or_<typename boost::msm::back::is_composite_state<StateType>::type, typename boost::msm::back::is_pseudo_exit<StateType>::type>::type, void>::type boost::msm::back::state_machine<A0, A1, A2, A3, A4>::execute_entry(StateType&, const EventType&, FsmType&, boost::msm::back::dummy<1>) [with StateType = B; EventType = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; FsmType = boost::msm::back::state_machine<SubMachineDefinition>; A0 = SubMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_; typename boost::disable_if<typename boost::mpl::or_<typename boost::msm::back::is_composite_state<StateType>::type, typename boost::msm::back::is_pseudo_exit<StateType>::type>::type, void>::type = void]':
/usr/local/include/boost/msm/back/state_machine.hpp:2396:31:   required from 'typename boost::enable_if<typename IsEntry::type, void>::type boost::msm::back::state_machine<A0, A1, A2, A3, A4>::entry_exit_helper<Event, is_entry>::helper(boost::msm::back::dummy<0>) [with IsEntry = mpl_::bool_<true>; State = B; Event = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; bool is_entry = true; A0 = SubMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_; typename boost::enable_if<typename IsEntry::type, void>::type = void]'
/usr/local/include/boost/msm/back/state_machine.hpp:2414:104:   required from 'void boost::msm::back::state_machine<A0, A1, A2, A3, A4>::entry_exit_helper<Event, is_entry>::operator()(const boost::msm::wrap<State>&) [with State = B; Event = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; bool is_entry = true; A0 = SubMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_]'
/usr/local/include/boost/mpl/for_each.hpp:78:25:   required from 'static void boost::mpl::aux::for_each_impl<false>::execute(Iterator*, LastIterator*, TransformFunc*, F) [with Iterator = boost::mpl::s_iter<boost::mpl::s_item<B, boost::mpl::s_item<A, boost::mpl::set0<> > >, boost::mpl::s_item<B, boost::mpl::s_item<A, boost::mpl::set0<> > > >; LastIterator = boost::mpl::s_iter<boost::mpl::s_item<B, boost::mpl::s_item<A, boost::mpl::set0<> > >, boost::mpl::set0<> >; TransformFunc = boost::msm::wrap<mpl_::arg<1> >; F = boost::msm::back::state_machine<SubMachineDefinition>::entry_exit_helper<boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent, true>]'
/usr/local/include/boost/mpl/for_each.hpp:105:97:   required from 'void boost::mpl::for_each(F, Sequence*, TransformOp*) [with Sequence = boost::mpl::s_item<B, boost::mpl::s_item<A, boost::mpl::set0<> > >; TransformOp = boost::msm::wrap<mpl_::arg<1> >; F = boost::msm::back::state_machine<SubMachineDefinition>::entry_exit_helper<boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent, true>]'
/usr/local/include/boost/msm/back/state_machine.hpp:2431:103:   required from 'static void boost::msm::back::state_machine<A0, A1, A2, A3, A4>::region_start_helper<region_id, Dummy>::do_start(boost::msm::back::state_machine<A0, A1, A2, A3, A4>::library_sm*, const Event&) [with Event = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; region_id = mpl_::int_<0>; int Dummy = 0; A0 = SubMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_; boost::msm::back::state_machine<A0, A1, A2, A3, A4>::library_sm = boost::msm::back::state_machine<SubMachineDefinition>]'
/usr/local/include/boost/msm/back/state_machine.hpp:2447:83:   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/boost/msm/back/state_machine.hpp:2717:9:   required from 'static typename boost::enable_if<typename boost::msm::back::is_composite_state<StateType>::type, void>::type boost::msm::back::state_machine<A0, A1, A2, A3, A4>::execute_entry(StateType&, const EventType&, FsmType&, boost::msm::back::dummy<0>) [with StateType = boost::msm::back::state_machine<SubMachineDefinition>; EventType = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; FsmType = boost::msm::back::state_machine<SuperMachineDefinition>; A0 = SuperMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_; typename boost::enable_if<typename boost::msm::back::is_composite_state<StateType>::type, void>::type = void]'
/usr/local/include/boost/msm/back/state_machine.hpp:2070:90:   required from 'void boost::msm::back::state_machine<A0, A1, A2, A3, A4>::call_init<Event>::operator()(const boost::msm::wrap<State>&) [with State = boost::msm::back::state_machine<SubMachineDefinition>; Event = boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent; A0 = SuperMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_]'
/usr/local/include/boost/mpl/for_each.hpp:78:25:   required from 'static void boost::mpl::aux::for_each_impl<false>::execute(Iterator*, LastIterator*, TransformFunc*, F) [with Iterator = boost::mpl::v_iter<boost::mpl::v_item<boost::msm::back::state_machine<SubMachineDefinition>, boost::mpl::vector0<mpl_::na>, 0>, 0l>; LastIterator = boost::mpl::v_iter<boost::mpl::v_item<boost::msm::back::state_machine<SubMachineDefinition>, boost::mpl::vector0<mpl_::na>, 0>, 1l>; TransformFunc = boost::msm::wrap<mpl_::arg<1> >; F = boost::msm::back::state_machine<SuperMachineDefinition>::call_init<boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent>]'
/usr/local/include/boost/mpl/for_each.hpp:105:97:   required from 'void boost::mpl::for_each(F, Sequence*, TransformOp*) [with Sequence = boost::mpl::v_item<boost::msm::back::state_machine<SubMachineDefinition>, boost::mpl::vector0<mpl_::na>, 0>; TransformOp = boost::msm::wrap<mpl_::arg<1> >; F = boost::msm::back::state_machine<SuperMachineDefinition>::call_init<boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent>]'
/usr/local/include/boost/msm/back/state_machine.hpp:1225:68:   required from 'void boost::msm::back::state_machine<A0, A1, A2, A3, A4>::start() [with A0 = SuperMachineDefinition; A1 = boost::parameter::void_; A2 = boost::parameter::void_; A3 = boost::parameter::void_; A4 = boost::parameter::void_]'
main.cpp:44:18:   required from here
/usr/local/include/boost/msm/back/state_machine.hpp:2728:9: error: no matching function for call to 'B::on_entry(const boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent&, boost::msm::back::state_machine<SubMachineDefinition>&)'
         astate.on_entry(remove_direct_entry_event_wrapper(evt),fsm);
         ^
/usr/local/include/boost/msm/back/state_machine.hpp:2728:9: note: candidate is:
main.cpp:16:30: note: template<class SM> void B::on_entry(const E&, SM&)
     template <class SM> void on_entry(E const&, SM&) { std::cout << __PRETTY_FUNCTION__ << "\n"; } 
                              ^
main.cpp:16:30: note:   template argument deduction/substitution failed:
In file included from main.cpp:3:0:
/usr/local/include/boost/msm/back/state_machine.hpp:2728:9: note:   cannot convert 'boost::msm::back::state_machine<A0, A1, A2, A3, A4>::remove_direct_entry_event_wrapper<boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent>((* & evt), (boost::msm::back::dummy<1>(0), boost::msm::back::dummy<1>()))' (type 'const boost::msm::back::state_machine<SuperMachineDefinition>::InitEvent') to type 'const E&'
         astate.on_entry(remove_direct_entry_event_wrapper(evt),fsm);
         ^
