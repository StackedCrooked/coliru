#include <stdio.h>#include <iostream>using namespace std;namespace detail { template <class T>  struct proxy{  T *resource_;}; } // detail template <class T>class MovableResource{  private:    T * resource_;   public:    explicit MovableResource (T * r = 0) : resource_(r) { }        ~MovableResource() throw()     {         delete resource_;        printf("\nMovableResource::~MovableResource()... 0x%x\n", this);    }   // Assuming std:::auto_ptr like behavior.        //MovableResource (const MovableResource &m) throw () // The "Move constructor" (note non-const parameter)    //  : resource_ (m.resource_)    //{    //  printf("\nMovableResource::MovableResource(const MovableResource &)\n");    //}     MovableResource (detail::proxy<T> p) throw () // The proxy move constructor      : resource_(p.resource_)    {      // Just copying resource pointer is sufficient. No need to NULL it like in the move constructor.      printf("\nMovableResource::MovableResource(detail::proxy<T>)... 0x%x\n", this);    }     MovableResource & operator = (detail::proxy<T> p) throw ()    {      // copy and swap idiom. Must release the original resource in the destructor.      MovableResource temp (p);      temp.swap(*this);      printf("\nMovableResource::operator = (detail::proxy<T>)... 0x%x\n", this);      return *this;    }     void swap (MovableResource &m) throw ()    {      std::swap (this->resource_, m.resource_);    }     operator detail::proxy<T> () throw () // A helper conversion function. Note that it is non-const    {      detail::proxy<T> p;      p.resource_ = this->resource_;      this->resource_ = 0;     // Resource moved to the temporary proxy object.      printf("\nMovableResource::operator detail::proxy<T>()... 0x%x\n", this);      return p;    }        private:    MovableResource (MovableResource &m) throw () // The "Move constructor" (note non-const parameter)      : resource_ (m.resource_)    {      m.resource_ = 0; // Note that resource in the parameter is moved into *this.      printf("\nMovableResource::MovableResource(MovableResource &)\n");    }        MovableResource & operator = (MovableResource &m) throw () // Move-assignment operator (note non-const parameter)    {      // copy and swap idiom. Must release the original resource in the destructor.      MovableResource temp (m); // Resources will be moved here.      temp.swap (*this);      printf("\nMovableResource::operator = (MovableResource &)\n");      return *this;    }};template <class T>MovableResource<T> move(MovableResource<T> & mr) throw() // Convert explicitly to a non-const reference to rvalue{  return MovableResource<T>(detail::proxy<T>(mr));}MovableResource<int> source(){  MovableResource<int> local(new int(999));  printf("\nsource()... 0x%x\n", &local);  return move(local);}void sink(MovableResource<int> mr){  // Do something with mr. mr is deleted automatically at the end.  printf("\nsink(MovableResource<int>)... 0x%x\n", &mr);}int main(void){  MovableResource<int> mr(source()); // OK  printf("\n(1) ---------------\n");  MovableResource<int> mr2;  printf("\n(2) ---------------\n");  //mr2 = mr;                          // Compiler error  mr2 = move(mr);                    // OK  printf("\n(3) ---------------\n");  //sink(mr2);                         // Compiler error  sink(move(mr2));                   // OK  printf("\n(4) ---------------\n");}