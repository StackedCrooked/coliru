main.cpp: In function 'int main()':
main.cpp:59:98: error: no matching function for call to 'Map(StringVector&, main()::<lambda(const string&)>)'
     const auto& vectorResult = Map(someVector, [] (const std::string& str) { return GetId(str); });
                                                                                                  ^
main.cpp:59:98: note: candidates are:
main.cpp:4:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<(! std::is_same<void, typename std::result_of<F(T)>::type>::value), Container<typename std::decay<typename std::result_of<F(T)>::type>::type, A> >::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>&c, F f) -> typename std::enable_if<!std::is_same<void, typename std::result_of<F (T)>::type>::value,
      ^
main.cpp:4:6: note:   template argument deduction/substitution failed:
main.cpp:59:98: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringVector'
     const auto& vectorResult = Map(someVector, [] (const std::string& str) { return GetId(str); });
                                                                                                  ^
main.cpp:14:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>& c, F f) -> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type
      ^
main.cpp:14:6: note:   template argument deduction/substitution failed:
main.cpp:59:98: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringVector'
     const auto& vectorResult = Map(someVector, [] (const std::string& str) { return GetId(str); });
                                                                                                  ^
main.cpp:60:94: error: no matching function for call to 'Map(StringList&, main()::<lambda(const string&)>)'
     const auto& listResult = Map(someList, [] (const std::string& str) { return GetId(str); });
                                                                                              ^
main.cpp:60:94: note: candidates are:
main.cpp:4:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<(! std::is_same<void, typename std::result_of<F(T)>::type>::value), Container<typename std::decay<typename std::result_of<F(T)>::type>::type, A> >::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>&c, F f) -> typename std::enable_if<!std::is_same<void, typename std::result_of<F (T)>::type>::value,
      ^
main.cpp:4:6: note:   template argument deduction/substitution failed:
main.cpp:60:94: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringList'
     const auto& listResult = Map(someList, [] (const std::string& str) { return GetId(str); });
                                                                                              ^
main.cpp:14:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>& c, F f) -> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type
      ^
main.cpp:14:6: note:   template argument deduction/substitution failed:
main.cpp:60:94: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringList'
     const auto& listResult = Map(someList, [] (const std::string& str) { return GetId(str); });
                                                                                              ^
main.cpp:61:96: error: no matching function for call to 'Map(StringDeque&, main()::<lambda(const string&)>)'
     const auto& dequeResult = Map(someDeque, [] (const std::string& str) { return GetId(str); });
                                                                                                ^
main.cpp:61:96: note: candidates are:
main.cpp:4:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<(! std::is_same<void, typename std::result_of<F(T)>::type>::value), Container<typename std::decay<typename std::result_of<F(T)>::type>::type, A> >::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>&c, F f) -> typename std::enable_if<!std::is_same<void, typename std::result_of<F (T)>::type>::value,
      ^
main.cpp:4:6: note:   template argument deduction/substitution failed:
main.cpp:61:96: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringDeque'
     const auto& dequeResult = Map(someDeque, [] (const std::string& str) { return GetId(str); });
                                                                                                ^
main.cpp:14:6: note: template<class T, class A, template<class, class> class Container, class F> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type Map(const Container<T, A>&, F)
 auto Map (const Container<T, A>& c, F f) -> typename std::enable_if<std::is_same<void, typename std::result_of<F(T)>::type>::value>::type
      ^
main.cpp:14:6: note:   template argument deduction/substitution failed:
main.cpp:61:96: note:   can't deduce a template for 'const Container<T, A>' from non-template type 'StringDeque'
     const auto& dequeResult = Map(someDeque, [] (const std::string& str) { return GetId(str); });
                                                                                                ^
main.cpp:63:34: error: no matching function for call to 'idof()'
     idof<decltype(vectorResult)>();
                                  ^
main.cpp:63:34: note: candidates are:
main.cpp:49:6: note: template<class T> void idof()
 void idof() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
      ^
main.cpp:49:6: note:   template argument deduction/substitution failed:
main.cpp:63:34: error: template argument 1 is invalid
     idof<decltype(vectorResult)>();
                                  ^
main.cpp:52:6: note: template<class T> void idof(T&&)
 void idof(T&&) { idof<T>(); }
      ^
main.cpp:52:6: note:   template argument deduction/substitution failed:
main.cpp:63:34: error: template argument 1 is invalid
     idof<decltype(vectorResult)>();
                                  ^
main.cpp:64:32: error: no matching function for call to 'idof()'
     idof<decltype(listResult)>();
                                ^
main.cpp:64:32: note: candidates are:
main.cpp:49:6: note: template<class T> void idof()
 void idof() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
      ^
main.cpp:49:6: note:   template argument deduction/substitution failed:
main.cpp:64:32: error: template argument 1 is invalid
     idof<decltype(listResult)>();
                                ^
main.cpp:52:6: note: template<class T> void idof(T&&)
 void idof(T&&) { idof<T>(); }
      ^
main.cpp:52:6: note:   template argument deduction/substitution failed:
main.cpp:64:32: error: template argument 1 is invalid
     idof<decltype(listResult)>();
                                ^
main.cpp:65:33: error: no matching function for call to 'idof()'
     idof<decltype(dequeResult)>();
                                 ^
main.cpp:65:33: note: candidates are:
main.cpp:49:6: note: template<class T> void idof()
 void idof() { std::cout << __PRETTY_FUNCTION__ << '\n'; }
      ^
main.cpp:49:6: note:   template argument deduction/substitution failed:
main.cpp:65:33: error: template argument 1 is invalid
     idof<decltype(dequeResult)>();
                                 ^
main.cpp:52:6: note: template<class T> void idof(T&&)
 void idof(T&&) { idof<T>(); }
      ^
main.cpp:52:6: note:   template argument deduction/substitution failed:
main.cpp:65:33: error: template argument 1 is invalid
     idof<decltype(dequeResult)>();
                                 ^
main.cpp:67:33: error: 'begin' was not declared in this scope
     std::copy(begin(vectorResult), end(vectorResult), std::ostream_iterator<std::size_t>{std::cout, ", "});
                                 ^
main.cpp:67:33: note: suggested alternative:
In file included from /usr/local/include/c++/4.9.0/bits/basic_string.h:42:0,
                 from /usr/local/include/c++/4.9.0/string:52,
                 from main.cpp:20:
/usr/local/include/c++/4.9.0/initializer_list:89:5: note:   'std::begin'
     begin(initializer_list<_Tp> __ils) noexcept
     ^
main.cpp:67:52: error: 'end' was not declared in this scope
     std::copy(begin(vectorResult), end(vectorResult), std::ostream_iterator<std::size_t>{std::cout, ", "});
                                                    ^
main.cpp:67:52: note: suggested alternative:
In file included from /usr/local/include/c++/4.9.0/bits/basic_string.h:42:0,
                 from /usr/local/include/c++/4.9.0/string:52,
                 from main.cpp:20:
/usr/local/include/c++/4.9.0/initializer_list:99:5: note:   'std::end'
     end(initializer_list<_Tp> __ils) noexcept
     ^
