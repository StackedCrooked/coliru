In file included from /usr/local/include/boost/spirit/home/qi/auxiliary/attr.hpp:18:0,
                 from /usr/local/include/boost/spirit/home/qi/auxiliary.hpp:19,
                 from /usr/local/include/boost/spirit/home/qi.hpp:16,
                 from /usr/local/include/boost/spirit/include/qi.hpp:16,
                 from main.cpp:2:
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp: In instantiation of ‘struct boost::spirit::traits::detail::is_container_of_ranges<identifier>’:
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:71:80:   required from ‘static void boost::spirit::traits::assign_to_attribute_from_iterators<Attribute, Iterator, Enable>::call(const Iterator&, const Iterator&, Attribute&) [with Attribute = identifier; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Enable = void]’
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:123:35:   required from ‘void boost::spirit::traits::assign_to(const Iterator&, const Iterator&, Attribute&) [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Attribute = identifier]’
/usr/local/include/boost/spirit/home/qi/directive/raw.hpp:65:57:   required from ‘bool boost::spirit::qi::raw_directive<Subject>::parse(Iterator&, const Iterator&, Context&, const Skipper&, Attribute&) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Skipper = boost::spirit::unused_type; Attribute = identifier; Subject = boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > >]’
/usr/local/include/boost/spirit/home/qi/nonterminal/detail/parser_binder.hpp:43:54:   required from ‘bool boost::spirit::qi::detail::parser_binder<Parser, Auto>::call(Iterator&, const Iterator&, Context&, const Skipper&, mpl_::false_) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Skipper = boost::spirit::unused_type; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Parser = boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >; Auto = mpl_::bool_<false>; mpl_::false_ = mpl_::bool_<false>]’
/usr/local/include/boost/spirit/home/qi/nonterminal/detail/parser_binder.hpp:53:67:   required from ‘bool boost::spirit::qi::detail::parser_binder<Parser, Auto>::operator()(Iterator&, const Iterator&, Context&, const Skipper&) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Skipper = boost::spirit::unused_type; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Parser = boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >; Auto = mpl_::bool_<false>]’
/usr/local/include/boost/function/function_template.hpp:132:42:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/boost/function/function_template.hpp:722:7:   required from ‘boost::function4<R, T1, T2, T3, T4>::function4(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/local/include/boost/function/function_template.hpp:1069:16:   required from ‘boost::function<R(T0, T1, T2, T3)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/local/include/boost/function/function_template.hpp:1124:5:   required from ‘typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, boost::function<R(T0, T1, T2, T3)>&>::type boost::function<R(T0, T1, T2, T3)>::operator=(Functor) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, boost::function<R(T0, T1, T2, T3)>&>::type = boost::function<bool(__gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&, const boost::spirit::unused_type&)>&]’
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:182:19:   required from ‘static void boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::define(boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>&, const Expr&, mpl_::true_) [with Auto = mpl_::bool_<false>; Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::raw>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::lexeme>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::dereference, boost::proto::argsns_::list1<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&>, 1l>&>, 2l>&>, 2l>&>, 2l>; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; T1 = identifier(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; mpl_::true_ = mpl_::bool_<true>]’
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:191:19:   required from ‘boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::rule(const Expr&, const string&) [with Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::raw>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::lexeme>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::dereference, boost::proto::argsns_::list1<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&>, 1l>&>, 2l>&>, 2l>&>, 2l>; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; T1 = identifier(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; std::string = std::basic_string<char>]’
main.cpp:35:117:   required from here
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:40:16: error: no type named ‘value_type’ in ‘struct identifier’
         struct is_container_of_ranges
                ^
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp: In instantiation of ‘static void boost::spirit::traits::assign_to_attribute_from_iterators<Attribute, Iterator, Enable>::call(const Iterator&, const Iterator&, Attribute&) [with Attribute = identifier; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Enable = void]’:
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:123:35:   required from ‘void boost::spirit::traits::assign_to(const Iterator&, const Iterator&, Attribute&) [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Attribute = identifier]’
/usr/local/include/boost/spirit/home/qi/directive/raw.hpp:65:57:   required from ‘bool boost::spirit::qi::raw_directive<Subject>::parse(Iterator&, const Iterator&, Context&, const Skipper&, Attribute&) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Skipper = boost::spirit::unused_type; Attribute = identifier; Subject = boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > >]’
/usr/local/include/boost/spirit/home/qi/nonterminal/detail/parser_binder.hpp:43:54:   required from ‘bool boost::spirit::qi::detail::parser_binder<Parser, Auto>::call(Iterator&, const Iterator&, Context&, const Skipper&, mpl_::false_) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Skipper = boost::spirit::unused_type; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Parser = boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >; Auto = mpl_::bool_<false>; mpl_::false_ = mpl_::bool_<false>]’
/usr/local/include/boost/spirit/home/qi/nonterminal/detail/parser_binder.hpp:53:67:   required from ‘bool boost::spirit::qi::detail::parser_binder<Parser, Auto>::operator()(Iterator&, const Iterator&, Context&, const Skipper&) const [with Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Skipper = boost::spirit::unused_type; Context = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >; Parser = boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >; Auto = mpl_::bool_<false>]’
/usr/local/include/boost/function/function_template.hpp:132:42:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/boost/function/function_template.hpp:722:7:   required from ‘boost::function4<R, T1, T2, T3, T4>::function4(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/local/include/boost/function/function_template.hpp:1069:16:   required from ‘boost::function<R(T0, T1, T2, T3)>::function(Functor, typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, int>::type = int]’
/usr/local/include/boost/function/function_template.hpp:1124:5:   required from ‘typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, boost::function<R(T0, T1, T2, T3)>&>::type boost::function<R(T0, T1, T2, T3)>::operator=(Functor) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::raw_directive<boost::spirit::qi::lexeme_directive<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > >, boost::fusion::cons<boost::spirit::qi::kleene<boost::spirit::qi::alternative<boost::fusion::cons<boost::spirit::qi::char_class<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, boost::fusion::cons<boost::spirit::qi::literal_char<boost::spirit::char_encoding::standard, true, false>, boost::fusion::nil> > > >, boost::fusion::nil> > > > >, mpl_::bool_<false> >; R = bool; T0 = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T1 = const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&; T2 = boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<boost::type_traits::ice_not<boost::is_integral<Functor>::value>::value, boost::function<R(T0, T1, T2, T3)>&>::type = boost::function<bool(__gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, boost::spirit::context<boost::fusion::cons<identifier&, boost::fusion::nil>, boost::fusion::vector0<> >&, const boost::spirit::unused_type&)>&]’
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:182:19:   required from ‘static void boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::define(boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>&, const Expr&, mpl_::true_) [with Auto = mpl_::bool_<false>; Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::raw>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::lexeme>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::dereference, boost::proto::argsns_::list1<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&>, 1l>&>, 2l>&>, 2l>&>, 2l>; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; T1 = identifier(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; mpl_::true_ = mpl_::bool_<true>]’
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:191:19:   required from ‘boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::rule(const Expr&, const string&) [with Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::raw>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::subscript, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::lexeme>, 0l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alpha, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&, const boost::proto::exprns_::expr<boost::proto::tagns_::tag::dereference, boost::proto::argsns_::list1<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::bitwise_or, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<boost::spirit::tag::char_code<boost::spirit::tag::alnum, boost::spirit::char_encoding::standard> >, 0l>&, boost::proto::exprns_::expr<boost::proto::tagns_::tag::terminal, boost::proto::argsns_::term<const char&>, 0l> >, 2l>&>, 1l>&>, 2l>&>, 2l>&>, 2l>; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; T1 = identifier(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; std::string = std::basic_string<char>]’
main.cpp:35:117:   required from here
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:71:80: error: no matching function for call to ‘boost::spirit::traits::assign_to_attribute_from_iterators<identifier, __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >, void>::call(const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, const __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >&, identifier&, boost::spirit::traits::detail::is_container_of_ranges<identifier>)’
             call(first, last, attr, detail::is_container_of_ranges<Attribute>());
                                                                                ^
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:71:80: note: candidates are:
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:49:9: note: static void boost::spirit::traits::assign_to_attribute_from_iterators<Attribute, Iterator, Enable>::call(const Iterator&, const Iterator&, Attribute&, mpl_::false_) [with Attribute = identifier; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Enable = void; mpl_::false_ = mpl_::bool_<false>]
         call(Iterator const& first, Iterator const& last, Attribute& attr, mpl::false_)
         ^
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:49:9: note:   no known conversion for argument 4 from ‘boost::spirit::traits::detail::is_container_of_ranges<identifier>’ to ‘mpl_::false_ {aka mpl_::bool_<false>}’
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:62:9: note: static void boost::spirit::traits::assign_to_attribute_from_iterators<Attribute, Iterator, Enable>::call(const Iterator&, const Iterator&, Attribute&, mpl_::true_) [with Attribute = identifier; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Enable = void; mpl_::true_ = mpl_::bool_<true>]
         call(Iterator const& first, Iterator const& last, Attribute& attr, mpl::true_)
         ^
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:62:9: note:   no known conversion for argument 4 from ‘boost::spirit::traits::detail::is_container_of_ranges<identifier>’ to ‘mpl_::true_ {aka mpl_::bool_<true>}’
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:69:9: note: static void boost::spirit::traits::assign_to_attribute_from_iterators<Attribute, Iterator, Enable>::call(const Iterator&, const Iterator&, Attribute&) [with Attribute = identifier; Iterator = __gnu_cxx::__normal_iterator<const wchar_t*, std::basic_string<wchar_t> >; Enable = void]
         call(Iterator const& first, Iterator const& last, Attribute& attr)
         ^
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:69:9: note:   candidate expects 3 arguments, 4 provided
