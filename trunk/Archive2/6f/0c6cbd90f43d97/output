main.cpp:3:5: error: expected unqualified-id before 'protected'
     protected:
     ^
main.cpp:6:19: error: 'F1' has not been declared
         template <F1 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                   ^
main.cpp: In function 'void add_method(const char*, const char*)':
main.cpp:1:33: error: 'PyCFunction' does not name a type
 #define PCF(x) reinterpret_cast<PyCFunction>(x)
                                 ^
main.cpp:6:112: note: in expansion of macro 'PCF'
         template <F1 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                                                                                                                ^
main.cpp:6:117: error: 'handler' was not declared in this scope
         template <F1 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                                                                                                                     ^
main.cpp:1:46: note: in definition of macro 'PCF'
 #define PCF(x) reinterpret_cast<PyCFunction>(x)
                                              ^
main.cpp:1:47: error: expected primary-expression before ')' token
 #define PCF(x) reinterpret_cast<PyCFunction>(x)
                                               ^
main.cpp:6:112: note: in expansion of macro 'PCF'
         template <F1 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                                                                                                                ^
main.cpp: At global scope:
main.cpp:7:19: error: 'F2' has not been declared
         template <F2 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                   ^
main.cpp:7:37: error: redefinition of 'template<int f> void add_method(const char*, const char*)'
         template <F2 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                                     ^
main.cpp:6:37: note: 'template<int f> void add_method(const char*, const char*)' previously declared here
         template <F1 f> static void add_method( const char* name, const char* doc="" )  { add_method( name, f, PCF(&handler<f>), doc ); }
                                     ^
main.cpp:9:5: error: expected unqualified-id before 'private'
     private:
     ^
main.cpp:13:16: error: 'PyObject' does not name a type
         static PyObject* handlerX( int i, std::function<Object()> lambda )
                ^
main.cpp:28:19: error: 'F0' has not been declared
         template< F0 f > static P handler( P o, P   )      { return handlerX( 0, [&] ()->Object { return (final(o) ->* f)(                         ); }  ); }
                   ^
main.cpp:27:19: error: 'PyObject' does not name a type
         #define P PyObject*
                   ^
main.cpp:28:33: note: in expansion of macro 'P'
         template< F0 f > static P handler( P o, P   )      { return handlerX( 0, [&] ()->Object { return (final(o) ->* f)(                         ); }  ); }
                                 ^
main.cpp:29:19: error: 'F1' has not been declared
         template< F1 f > static P handler( P o, P a )      { return handlerX( 1, [&] ()->Object { return (final(o) ->* f)( to_tuple(a)             ); }  ); }
                   ^
main.cpp:27:19: error: 'PyObject' does not name a type
         #define P PyObject*
                   ^
main.cpp:29:33: note: in expansion of macro 'P'
         template< F1 f > static P handler( P o, P a )      { return handlerX( 1, [&] ()->Object { return (final(o) ->* f)( to_tuple(a)             ); }  ); }
                                 ^
main.cpp:30:19: error: 'F2' has not been declared
         template< F2 f > static P handler( P o, P a, P k ) { return handlerX( 2, [&] ()->Object { return (final(o) ->* f)( to_tuple(a), to_dict(k) ); }  ); }
                   ^
main.cpp:27:19: error: 'PyObject' does not name a type
         #define P PyObject*
                   ^
main.cpp:30:33: note: in expansion of macro 'P'
         template< F2 f > static P handler( P o, P a, P k ) { return handlerX( 2, [&] ()->Object { return (final(o) ->* f)( to_tuple(a), to_dict(k) ); }  ); }
                                 ^
