main.cpp:204:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:207:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:210:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:213:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:216:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:219:13: warning: unused parameter 'sig' [-Wunused-parameter]
main.cpp:219:13: warning: unused parameter 'si' [-Wunused-parameter]
main.cpp:219:13: warning: unused parameter 'unused' [-Wunused-parameter]
std::thread::hardware_concurrency() = 1
default value:
    corePoolSize = 1, maximumPoolSize = 1, keepAliveTime = 300000 ms.
new value:
    corePoolSize = 4, maximumPoolSize = 8, keepAliveTime = 2000 ms.
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
2外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3.    conditionVariable_.wait(lk);→exit.
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
3.    conditionVariable_.wait(lk);→exit.
3内
3内
3内
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5外
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
notify.
notify.
notify.
notify.
3.    conditionVariable_.wait(lk);→exit.
3内
3内
3内
3内
2.    conditionVariable_.wait(lk);→exit.
32.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4.    conditionVariable_.wait(lk);→exit.
4.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.if (!enabled) {
4.    conditionVariable_.wait(lk);→exit.
4.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4退出.if (!enabled) {
3.    conditionVariable_.wait(lk);→exit.
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3退出.if (!enabled) {
6外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
2.    conditionVariable_.wait(lk);→exit.
notify.
notify.
notify.
2内
2内
2内
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.if (!enabled) {
3.    conditionVariable_.wait(lk);→exit.
3.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
3退出.ok.
6.    conditionVariable_.wait(lk);→exit.
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
4.    conditionVariable_.wait(lk);→exit.
4.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
4退出.ok.
7外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
notify.
notify.
8外
2.    conditionVariable_.wait(lk);→exit.
2内
2内
2内
2内
2内
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
2退出.if (!enabled) {
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
6.    conditionVariable_.wait(lk);→exit.
6内
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
9外
notify.
8.    conditionVariable_.wait(lk);→exit.
8内
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
notify.
notify.
6.    conditionVariable_.wait(lk);→exit.
6内
6内
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.if (!enabled) {
notify.
notify.
notify.
notify.
5.    conditionVariable_.wait(lk);→exit.
5内
5内
5内
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
2.    conditionVariable_.wait(lk);→exit.
2.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
2退出.ok.
notify.
8.    conditionVariable_.wait(lk);→exit.
8内
8内
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
notify.
9.    conditionVariable_.wait(lk);→exit.
9内
9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
8.    conditionVariable_.wait(lk);→exit.
8内
8内
8内
8内
8内
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
9.    conditionVariable_.wait(lk);→exit.
9.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
9退出.ok.
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
notify.
notify.
10外
8.    conditionVariable_.wait(lk);→exit.
8内
8内
8内
8内
8内
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.if (!enabled) {
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
notify.
notify.
notify.
10.    conditionVariable_.wait(lk);→exit.
10内
10内
10内
10内
10内
10内
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
10退出.if (!enabled) {
8.    conditionVariable_.wait(lk);→exit.
8.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
8退出.ok.
11外
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
12notify.
外
10.    conditionVariable_.wait(lk);→exit.
10内
10内
10内
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
10退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
notify.
7.    conditionVariable_.wait(lk);→exit.
7内
7内
7内
7内
7内
7内
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.if (!enabled) {
6.    conditionVariable_.wait(lk);→exit.
6.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
6退出.ok.
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
notify.
notify.
notify.
notify.
notify.
notify.
13外
11.    conditionVariable_.wait(lk);→exit.
11内
11内
11内
11内
11内
11内
11.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
11退出.if (!enabled) {
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
5.    conditionVariable_.wait(lk);→exit.
5内
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5退出.if (!enabled) {
14外
notify.
notify.
notify.
notify.
notify.
notify.
notify.
notify.
10.    conditionVariable_.wait(lk);→exit.
10内
10内
10内
10内
10内
10内
10内
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
10退出.if (!enabled) {
12.    conditionVariable_.wait(lk);→exit.
12.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
12退出.if (!enabled) {
7.    conditionVariable_.wait(lk);→exit.
7.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
7退出.ok.
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {
13.    conditionVariable_.wait(lk);→exit.
13内
13.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
13退出.if (!enabled) {
notify.
15外
notify.
14.    conditionVariable_.wait(lk);→exit.
14内
notify.
14内
14内
14.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
14退出.if (!enabled) {
notify.
notify.
notify.
notify.
notify.
10.    conditionVariable_.wait(lk);→exit.
10内
10内
10内
10内
1410.    conditionVariable_.wait(lk);→exit.
notify.
12内
notify.
notify.
notify.
notify.
notify.
notify.
notify.
15.    conditionVariable_.wait(lk);→exit.
15内
15内
15内
15内
15内
15内
15内
15.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
15退出.if (!enabled) {
if (currentThreads_ < maximumPoolSize_ && taskQueueSize_ + 1 > currentThreads_) {.    conditionVariable_.wait(lk);→exit.
10
12.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
notify.
12notify.
14退出.ok.
notify.
notify.
.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
notify.
14退出.ok.
10退出.if (!enabled) {
1316.    conditionVariable_.wait(lk);→exit.
外
13内
13内
13内
13内
13内
13内
13.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
13退出.if (!enabled) {
11.    conditionVariable_.wait(lk);→exit.
11.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
11退出.ok.
15.    conditionVariable_.wait(lk);→exit.
15.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
15退出.ok.
10.    conditionVariable_.wait(lk);→exit.
10.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
5.    conditionVariable_.wait(lk);→exit.
5.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
13.    conditionVariable_.wait(lk);→exit.
13.    std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
Cleanup().
16.    conditionVariable_.wait(lk);→exit.
5.    conditionVariable_.wait(lk);→exit.
10.    conditionVariable_.wait(lk);→exit.
13.    conditionVariable_.wait(lk);→exit.
cnt = 4950
