#include <set>
#include <iostream>
#include <limits> 
#include <string>

/* ----------------------------------------------- GroupTheorizer class ----------------------------------------------------- */

class GroupTheorizer
{
public:
    GroupTheorizer() {}; // trivial constructor
    ~GroupTheorizer() {}; // trivial destructor
    template <typename ObType, typename BinaryFunction> void print_Group_Info(const std::set<ObType> &, BinaryFunction &) const;
    template <typename ObType, typename BinaryFunction> bool isCyclic(const std::set<ObType> &, BinaryFunction &, ObType &) const;
    template <typename ObType, typename BinaryFunction> bool isAbelian(const std::set<ObType> &, BinaryFunction &) const;
    template <typename ObType, typename BinaryFunction> bool isGroup(const std::set<ObType> &, BinaryFunction &, ObType &) const;
    template <typename T> void fillAllValues(std::set<T> &) const;
private: 
    template <typename T> std::string set2Str(const std::set<T> &) const;

};


template <typename ObType, typename BinaryFunction>
void GroupTheorizer::print_Group_Info(const std::set<ObType> & S, BinaryFunction & op) const
{
    std::cout << set2Str(S) << std::endl;
    std::cout << "with operator " << op.getSymbol() << std::endl;
    ObType i = ObType();
    if (isGroup(S, op, i))
    {
        std::cout << "is a group, with identity element " << i << "," << std::endl;
        ObType g = ObType();
        if (isCyclic(S, op, g))
        {
            std::cout << "is cyclic, generated by element" << g << "," <<  std::endl;
            std::cout << "and is Abelian as a consqeuence." << std::endl;
        }
        else
        {
            std::cout << "is not cyclic" << "," << std::endl;
            std::cout << "and is " << (!isAbelian(S, op) ? "not" : "") << "Abelian." << std::endl;
        }


    }
    else
    {
        std::cout << "is not a group." << std::endl;
    }
}

template <typename T>
std::string GroupTheorizer::set2Str(const std::set<T> & S) const
{
    /* Returns a string representation of a set,  e.g. set2Str({1, 69, 111}) = "{1, 69, 111}" */
    std::string retstr = "{";
    typename std::set<T>::const_iterator it(S.cbegin()), offend(S.cend());
    if (it != offend)
        retstr.append(std::to_string(*it++));
    while (it != offend)
        retstr.append("," + std::to_string(*it++));
    retstr.push_back('}');
    return retstr;
}

template <typename T>
void GroupTheorizer::fillAllValues(std::set<T> & s) const
/* Given a set s of types T, fills S will all elements of type T. */
{
    T t = T();
    do 
        s.insert(t++); 
    while 
        (t != T());
}

template <typename ObType, typename BinaryFunction>
bool GroupTheorizer::isCyclic(const std::set<ObType> & G, BinaryFunction & op, ObType & g) const
{
    /*
    isCyclic returns true or false depending on whether the group G
    is an cyclic group, that is, whether it can be generated from
    one its elements. Formally, G is cyclic if there exists an 
    element g in G such that, for all elements h in g, 
    h = g^n for some n. 
    */
    bool foundGenerator = false;
    size_t maxN = G.size();
    /*
    Guaranteed that for each x in G, x^(maxN + 1) will be in the set
    {x, x^2, ..., x^maxN}. That is the meaning of maxN. 
    */

    for (typename std::set<ObType>::const_iterator it(G.cbegin()), offend(G.cend()); it != offend && !foundGenerator; ++it)
    {
        ObType e0 = *it; 
        ObType e = e0;
        std::set<ObType> powSet = {e};
        size_t k = 2;
        while (k <= maxN)
        {
            e = op(e, e0); /* Sets e equal to e^i */
            if (powSet.count(e) == 0)
                powSet.insert(e);
            else
                break;
            /* Why the break statement? 
               If e is already in powSet, then we've found a cycle but 
               powSet != G; therefore e cannot generate G.
            */
            ++k;
        }
        if (k == maxN) /* true iff (powSet == G) */
        {
            foundGenerator = true;
            g = e;
        }
    }
    return foundGenerator;
}


template <typename ObType, typename BinaryFunction>
bool GroupTheorizer::isAbelian(const std::set<ObType> & G, BinaryFunction & op) const
{
    /*
     isAbelian returns true or false depending on whether the group G
     is an Abelian group, that is, whether it's law of composition 
     op is commutative.
    */
    bool goodSoFar = true;
    typename std::set<ObType>::const_iterator beg(G.cbegin()), offend(G.cend());
    for (typename std::set<ObType>::const_iterator ia = beg; ia != offend && goodSoFar; ++ia)
    {
        for (typename std::set<ObType>::const_iterator ib = beg; ib != offend && goodSoFar; ++ib)
            if (op(*ia, *ib) != op(*ib, *ia))
                goodSoFar = false;
    }
    return goodSoFar;
}

template <typename ObType, typename BinaryFunction>
bool GroupTheorizer::isGroup(const std::set<ObType> & S, BinaryFunction & op, ObType & iden) const
{
    /*
       isGroup returns true or false depending on whether the set S
       along with the operator op is a group in the Algebraic sense.
       That is, S is a group if and only if all the 4 following
       conditions are true: 
            (1) If a, b in S, then a op b in S
            (2) If a, b, c in S, then (a op b) op c = a op (b op c)
            (3) There is an element 0 in S such that a op 0 = 0 op a = a for all a in S
            (4) If a in S, then there is a b in S such that a op b = b op a = 0
    */
    typename std::set<ObType>::const_iterator beg(S.cbegin()), offend(S.cend());
    bool noProblemsYet(beg != offend), foundIdentity(false);
    for (typename std::set<ObType>::const_iterator ia = beg; ia != offend && noProblemsYet; ++ia)
    {
        bool isIdentity = true;
        for (typename std::set<ObType>::const_iterator ib = beg; ib != offend && noProblemsYet; ++ib)
        {
            // ---------- (1) --------------
            if (S.count(op(*ia, *ib)) == 0)
                noProblemsYet = false;
            // ---------- (3) --------------
            if (op(*ia, *ib) != op(*ib, *ia) || op(*ib, *ia) != *ib)
                isIdentity = false;
            // -----------------------------
            for (typename std::set<ObType>::const_iterator ic = beg; ic != offend && noProblemsYet; ++ic)
            {
                // ---------- (2) -------------
                if (op(op(*ia, *ib), *ic) != op(*ia, op(*ib, *ic)))
                    noProblemsYet = false;
                // ----------------------------
            }
        }
        if (isIdentity)
        {
            foundIdentity = true;
            iden = *ia;
        }
    }

    if (noProblemsYet)
    {
        if (!foundIdentity)
            noProblemsYet = false;
        for (typename std::set<ObType>::const_iterator ia = beg; ia != offend && noProblemsYet; ++ia)
        {
            bool foundInverse = false;
            for (typename std::set<ObType>::const_iterator ib = beg; ib != offend && noProblemsYet; ++ib)
            {
                if (op(*ia, *ib) == op(*ib, *ia) && op(*ia, *ib) == iden)
                {
                    foundInverse = true;
                    break;
                }
            }
            // ---------- (4) -------------
            if (!foundInverse)
                noProblemsYet = false;
            // ----------------------------
        }
    }

    return noProblemsYet;
}

/* ----------------------------- Functors --------------------------------------*/

template <typename T>
class Adder
{
    private:
        static const char symbol = '+';
    public:
        T operator() (const T & x, const T & y) const { return x + y; };
        char getSymbol(void) const { return symbol; };
};


template <typename T>
class Subtracter
{
    private:
        static const char symbol = '-';
    public:
        T operator() (const T & x, const T & y) const { return x - y; };
        char getSymbol(void) const { return symbol; };
};

template <typename T>
class Multiplier
{
    private:
        static const char symbol = '*';
    public:
        T operator() (const T & x, const T & y) const { return x * y; };
        char getSymbol(void) const { return symbol; };
};

template <typename T>
class Divider
{
    private:
        static const char symbol = '/';
    public:
        T operator() (const T & x, const T & y) const { return x / y; };
        char getSymbol(void) const { return symbol; };
};

template <typename T>
class Modder
{
    private:
        static const char symbol = '%';
    public:
        T operator() (const T & x, const T & y) const { return x % y; };
        char getSymbol(void) const { return symbol; };
};

/* ------------------------------------------------------------------------------*/


int main()
{
    GroupTheorizer GT;
    std::set<char> C;
    Adder<char> A;
    GT.fillAllValues(C);
    GT.print_Group_Info(C, A);


    return 0;
}