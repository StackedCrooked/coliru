/**
 * Problem 12
 * ----------
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
 * first ten terms would be:
 *   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *   10: 1,2,5,10
 *   15: 1,3,5,15
 *   21: 1,3,7,21
 *   28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */


#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>
#include <vector>
#include <stdint.h>



typedef std::map<uint64_t, uint64_t> Map;
Map get_prime_factors(uint64_t n);


template<typename T>
std::ostream& operator<<(std::ostream & os, const std::vector<T> & vec)
{
    os << "{ ";
    for (const auto & v : vec)
    {
        os << v << " ";
    }
    return os << "}";
}

template<typename T>
std::ostream& operator<<(std::ostream & os, const std::map<T, T> & vec)
{
    uint64_t c = 0;
    for (const auto & p : vec)
    {
        if (c++)
        {
            os << '*';
        }
        for (uint64_t i = 0; i < p.second; ++i)
        {
            if (i != 0)
            {
                os << '*';
            }
            os << p.first;
        }
    }
    return os;
}


bool is_prime(uint64_t n, const std::vector<uint64_t> & preceding)
{
    // precondition: "preceding" contains all primes < sqrt(n)

    for (auto p : preceding)
    {
        if ((p * p) > n)
        {
            return true;
        }

        if (n % p == 0)
        {
            return false;
        }
    }
    return true;
}


uint64_t next_prime(std::vector<uint64_t> & preceding)
{
    if (preceding.empty())
    {
        preceding.push_back(2);
        return preceding.back();
    }

    if (preceding.back() == 2)
    {
        preceding.push_back(3);
        return preceding.back();
    }

    for (uint64_t n = preceding.back() + 2; ; n += 2)
    {
        if (is_prime(n, preceding))
        {
            preceding.push_back(n);
            return preceding.back();
        }
    }
}


uint64_t num_divisors(uint64_t n)
{
    uint64_t result = 1;
    for (auto pair : get_prime_factors(n))
    {
        result *= (pair.second + 1);
    }
    return result;
}


uint64_t triangle(uint64_t n)
{
    return n % 2 == 0 ? (n/2) * (n+1) : ((n+1)/2) * n;
}



Map operator+(Map lhs, const Map & rhs)
{
    for (auto p : rhs)
    {
        lhs[p.first] += p.second;
    }
    return lhs;
}


Map get_prime_factors(uint64_t n)
{
    std::map<uint64_t, uint64_t> result;
    static std::vector<uint64_t> pre = []{
        std::vector<uint64_t> result;
        for (int i = 0; i < 20000; ++i)
        {
            next_prime(result);
        }
        return result;
    }();

    if (n >= pre.size()) throw "n exceeds precalculated";

    for (uint64_t i = 0; i < pre.size(); ++i)
    {
        auto p = pre[i];
        while (n % p == 0)
        {
            result[p]++;
            n /= p;
        }
        if (p > n)
        {
            return result;
        }
    }
    return result;
}


Map get_prime_factors_of_tr(uint64_t n)
{
    if (n%2 ==0)
    {
        return get_prime_factors(n/2) + get_prime_factors(n + 1);
    }
    else
    {
        return get_prime_factors(n) + get_prime_factors((n + 1)/2);
    }
}


uint64_t get_divisors_count_of_tr(uint64_t n)
{
    uint64_t result = 1;
    for (auto pair : get_prime_factors_of_tr(n))
    {
        result *= pair.second + 1;
    }
    return result;
}


int main()
{
    uint64_t max = 0;
    for (uint64_t i = 2; max <= 500; ++i)
    {
        auto div = get_divisors_count_of_tr(i);
        if (div > max)
        {
            max = div;
            std::cout << triangle(i) << ": " << div << std::endl;
        }
    }
}
