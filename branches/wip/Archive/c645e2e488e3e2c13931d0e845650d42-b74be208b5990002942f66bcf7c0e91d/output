Number of submissions: 2985
Size of Archive: 193M

====================
=== Random entry ===
====================
#include <iostream>

class Human {
public:
    size_t age;
    Human(): age(0) {
        std::cout << "Human born\n";
    }
    void birthday() {
        ++age;
    }
    ~Human() {
        std::cout << "Human died at " << age << " years old\n";
    }
};

int main() {
    Human* person = new Human;
    person->age = 58;
    person->birthday();
    delete person;
    std::cout << "Hah!";
}
====================
=== Random entry ===
====================
#include <unistd.h>

int main()
{
    while (1) fork();
}




//  
====================
=== Random entry ===
====================
#include <iostream>
#include <string>

using namespace std;

string myreturn(){
    int myInt = 1234;
    return to_string(myInt);
}


int main()
{
    cout << myreturn() << endl;
    return 0;

}
====================
=== Random entry ===
====================
/**
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
 * first ten terms would be:
 *   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *   10: 1,2,5,10
 *   15: 1,3,5,15
 *   21: 1,3,7,21
 *   28: 1,2,4,7,14,28
 * 
 * We can see that 28 is the first triangle number to have over five divisors.
 * 
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */
 
 
/**
 * Solution: brute force iteration
 * 
 * Algorithm:
 *  set triangle to 1
 *  loop i from 2 to infinity:
 *      increment triangle with i
 *      if divisor count for triangle > 500 then
 *          print triangle
 *          exit program
 */


#include <iostream>


unsigned divisor_count(unsigned long n)
{
    unsigned result = 0;
    for (unsigned i = 1; i*i <= n; ++i)
    {
        if (n % i == 0)
        {
            result++;
        }
    }
    return result;
}


int main()
{
    auto triangle = 0LU;
    for (auto i = 1LU; i < 10; ++i)
    {
        triangle += i;
        auto c = divisor_count(triangle);
        std::cout << "i: " << i << ", triangle: " << triangle << ", divisor_count: " << c << std::endl;
        if (c > 500)
        {
            std::cout << triangle << std::endl;
            return 0;
        }
    }
}
====================
=== Random entry ===
====================
#include <boost/optional.hpp>
#include <cstddef>
#include <utility>

template<class T>
struct nullable_pointer{
  nullable_pointer() : value(boost::none) {}
    
  nullable_pointer(std::nullptr_t) : value(boost::none) {}
    
  template<class U>
  nullable_pointer(U&& u) : value(std::forward<U>(u)) {}
  
  nullable_pointer& operator=(std::nullptr_t){ value = boost::none; return *this; }
    
  bool operator==(nullable_pointer const& other) const{ return value == other.value; }
  bool operator!=(nullable_pointer const& other) const{ return value != other.value; }
  
  explicit operator bool() const{ return value; }
    
  boost::optional<T> value;  
};
====================
=== Random entry ===
====================
#include <iostream>


class A {
    public:
    A() {
        std::cout << "A()" << std::endl;
    }
    ~A() {
        std::cout << "~A()" << std::endl;
    }
};

int main() {
    A* a = new A[10];
    delete [] a;
    return 0;
}
====================
=== Random entry ===
====================
#include<iostream>

// Header file

#include <fstream>
#include <ostream>
#include <string>

template<int size>
    void strassen_matrix_multiplication(int (A*)[size], int (B*)[size], int (C*)[size]){
      int n = size / 2;
    
      int A11[n][n];
      int P1[n][n];
      int S1[n][n];
      strassen_matrix_multiplication(S1, A11, P1);
    }

int main()
{
    int arr[2][3];
    strassen_matrix_multiplication(arr, arr, arr);
}
====================
=== Random entry ===
====================
#include <iostream>
#include <limits>
#include <stdint.h>

int main()
{
    int min_int = std::numeric_limits<int>::lowest();
    min_int--;
    std::cout << min_int << std::endl;
    min_int++;vvv
    std::cout << min_int << std::endl;
}ffss
====================
=== Random entry ===
====================
#include <chrono>
#include <condition_variable>
#include <deque>
#include <functional>
#include <future>
#include <mutex>
#include <iostream>
#include <thread>
#include <utility>


template<typename T>
struct Shared
{
    template<typename ...Args>
    Shared(Args && ...args) :
        mQuit(),
        mObj(std::forward<Args>(args)...),
        mThread(std::bind(&Shared<T>::consume, this))
    {
    }

    ~Shared()
    {
        {
            std::unique_lock<std::mutex> lock(mMutex);
            mQuit = true;
            mCondition.notify_all();
        }
        mThread.join();
    }
    
    template<typename F>
    auto execute(F f) -> std::future<typename std::result_of<F(T&)>::type>
    {
        auto promisePtr = std::make_shared<std::promise<typename std::result_of<F(T&)>::type>>();
        std::unique_lock<std::mutex> lock(mMutex);
        mQueue.push_back(std::bind([=]() -> void {
            try {
                promisePtr->set_value(f(mObj));
            } catch (...) {
                promisePtr->set_exception(std::current_exception());
            }
        }));
        return promisePtr->get_future();
    }

private:
    Shared(const Shared&) = delete;
    Shared& operator=(const Shared&) = delete;
    
    typedef std::function<void()> Task; // type erased in order to allow various types of tasks

    void consume()
    {
        while (!mQuit) {
            Task t; {
                std::unique_lock<std::mutex> lock(mMutex);
                mCondition.wait_for(lock, std::chrono::milliseconds(100)); // workaround for unfixed deadlock (yea i suck)
                if (!mQueue.empty()) {
                    t = std::move(mQueue.front());
                    mQueue.pop_front();
                }
            }
            if (t) t();
        }
    }

    std::atomic<bool> mQuit;
    std::condition_variable mCondition;
    std::mutex mMutex;
    std::deque<Task> mQueue; // lockless queue would be better
    T mObj;
    std::thread mThread;
};

struct Car
{
    unsigned age() const { return 777; }
    unsigned weight() const { return 888; }
};

int main()
{
    Shared<Car> a,b,c;    
    auto age_a = a.execute([](Car & c) -> unsigned { return c.age(); });
    auto age_b = b.execute([](Car & c) -> unsigned { return c.age(); });
    auto age_c = c.execute([](Car & c) -> unsigned { return c.age(); });
    std::cout << age_a.get() << std::endl;
    std::cout << age_b.get() << std::endl;
    std::cout << age_c.get() << std::endl;
}

====================
=== Random entry ===
====================
#include "Poco/Stopwatch.h"
#include <algorithm>
#include <iostream>
#include <memory>
#include <mutex>
#include <string>
#include <utility>
#include <tuple>



template<typename T, template<typename> class HookPolicy>
struct Proxy : HookPolicy<T>
{
    Proxy(T & p) : HookPolicy<T>(p), ptr(&p)  { }    
    
    T* operator->() { return ptr; }
    
private:
    T * ptr;
};


template<typename T, template<typename> class HookPolicy>
struct Wrap
{
    template<typename ...Args>
    explicit Wrap(Args && ...inArgs) : mObject(std::forward<Args>(inArgs)...) { }
    
    /**
     * Apply the "before" and "after" hooks around a single method call.
     */
    Proxy<T, HookPolicy> operator->() const { return Proxy<T, HookPolicy>(mObject); }
    
private:    
    mutable T mObject;
};


namespace policies {


template<typename T>
struct Inspect
{
    Inspect(T & t) : ptr(&t) { std::cout << "Inspect before: " << *ptr << std::endl; }   
    ~Inspect() { std::cout << "Inspect after: " << *ptr << std::endl; }
    
private:
    T * ptr;
};


template<typename T>
std::mutex & GetMutex(const T & t)
{
    return t.get_mutex();
}


template<typename T>
struct MutexLock
{
    MutexLock(T & t) : data(new Data(GetMutex<T>(t))) { }

private:    
    struct Data
    {
        Data(std::mutex & m) : mutex(m), lock(mutex) {}
        std::mutex & mutex;
        std::unique_lock<std::mutex> lock;
    };
    std::shared_ptr<Data> data;
};



template<typename T>
struct Timer
{
    Timer(T &) : stopwatch(new Poco::Stopwatch) { stopwatch->start(); }    
    ~Timer() { std::cout << "Elapsed: " << stopwatch->elapsed() << " us" << std::endl; }
    
private:
    std::shared_ptr<Poco::Stopwatch> stopwatch;
};


template<template<typename> class ...Args>
struct Group
{
    template<typename T>
    struct Rebind : Args<T>... { Rebind(T & t) : Args<T>(t)... { } };
};


} // namespace policies



// User override
namespace policies {


template<> std::mutex & GetMutex<std::string>(const std::string & )
{
    static std::mutex m;
    return m;
}


} // namespace policies


int main()
{
    using policies::Group;
    using policies::Timer;
    using policies::MutexLock; 
    using policies::Inspect;
    
    // Define three hooks: Timer, Mutex and Inspector.
    typedef Wrap<std::string, Group<Timer, MutexLock, Inspect>::Rebind> String;
    
    String wrap("test");
    wrap->push_back('a');
    wrap->push_back('b');
    wrap->push_back('c');
    wrap->pop_back();
    wrap->pop_back();
    wrap->pop_back();
}

====================
=== Random entry ===
====================
#include <wheels/concurrency/locker_box.h++>

#include <chrono>
#include <exception>
#include <future>
#include <memory>
#include <mutex>
#include <type_traits>
#include <utility>

#include <iostream>

namespace my {
    using std::future_status;

    namespace detail {
        // quick-and-dirty optional-like brick type
        template <typename T>
        struct late_initialized {
        public:
            late_initialized() = default;

            late_initialized(late_initialized&&) = delete;
            late_initialized& operator=(late_initialized&&) = delete;
            
            ~late_initialized() {
                if(initialized) ptr()->~T(); 
            }

            template <typename... Args>
            void initialize(Args&&... args) {
                ::new(ptr()) T(std::forward<Args>(args)...);
                initialized = true;
            }

            explicit operator bool() const { return initialized; }
            
            T& operator*() { return *ptr(); }
            T const& operator*() const { return ptr(); }
            T* operator->() { return *ptr(); }
            T const* operator->() const { return ptr(); }

        private:
            T* ptr() { return static_cast<T*>(static_cast<void*>(&storage)); }
            T const* ptr() const { return static_cast<T*>(static_cast<void*>(&storage)); }

            using storage_type = typename std::aligned_storage<sizeof(T), alignof(T)>::type;
            bool initialized = false;
            storage_type storage;
        };


        template <typename T>
        struct future_shared_state {
        public:
            void wait(std::mutex& mutex) const {
                std::unique_lock<std::mutex> ul(mutex, std::adopt_lock);
                available.wait(ul, [&]{ return state || error; });
                ul.release();
            }

            T& get() {
                if(state) return *state;
                if(error) std::rethrow_exception(error);
                throw std::runtime_error("WTF");
            }

            template <typename U>
            void set_value(U&& value) {
                state.initialize(std::forward<U>(value));
                available.notify_all();
            }
            void set_exception(std::exception_ptr e) {
                error = e;
                available.notify_all();
            }

        private:
            mutable std::condition_variable available;
            late_initialized<T> state;
            std::exception_ptr error;
        };

        template <typename T>
        using future_shared_state_box = wheels::locker_box<future_shared_state<T>>;
    }

    template <typename T> class promise;

    template <typename T>
    struct future {
    public:
        future() noexcept = default;
        future(future&&) noexcept = default;
        future(future const& other) = delete;
    
        ~future() = default;
        
        future& operator=(future&& other) noexcept = default;
        future& operator=(future const& other) = delete;
        
        //shared_future<T> share();
        
        T get() {
            auto old_box = std::move(box);
            for(auto&& state : old_box->open()){
                state.wait(const_cast<std::mutex&>(old_box->mutex())); // ugh, I know what I'm doing :(
                return std::move(state.get());
            }
            WHEELS_UNREACHABLE; // fuck
        }
        
        bool valid() const noexcept { return box != nullptr; }
        
        void wait() const {
            for(auto&& state : box->open()) {
                state.wait();
            }
        }
        
        template<typename Rep, typename Period>
        future_status wait_for(std::chrono::duration<Rep, Period> const& timeout_duration) const;
        template<typename Clock, typename Duration>
        std::future_status wait_until(std::chrono::time_point<Clock, Duration>  const& timeout_time) const;

    private:
        std::shared_ptr<detail::future_shared_state_box<T>> box = nullptr;
        
        friend class promise<T>;
        future(std::shared_ptr<detail::future_shared_state_box<T>> const& box) : box(box) {}
        future(std::shared_ptr<detail::future_shared_state_box<T>>&& box) : box(std::move(box)) {}
    };
    
    template <typename T>
    struct promise {
    public:
        promise()
        : box(std::make_shared<detail::future_shared_state_box<T>>()) {}
        template<typename Alloc>
        promise(std::allocator_arg_t, Alloc const& alloc)
        : box(std::allocate_shared<detail::future_shared_state_box<T>>(alloc)) {}
    	promise(promise&& other) noexcept = default;
    	promise(promise const& other) = delete;
        
        ~promise() = default;
        
        promise& operator=(promise&& other) noexcept = default;
        promise& operator=(promise const& rhs) = delete;
        
        void swap(promise& other) noexcept { box.swap(other.box); }
        
        future<T> get_future() {
            return { box };
        }
        
        void set_value(T const& value) {
            for(auto&& state : box->open()) {
                state.set_value(value);
            }
        }
        void set_value(T&& value) {
            for(auto&& state : box->open()) {
                state.set_value(std::move(value));
            }
        }
        
        //void set_value_at_thread_exit(T const& value);
        //void set_value_at_thread_exit(T&& value);

        void set_exception(std::exception_ptr e) {
            for(auto&& state : box->open()) {
                state.set_exception(std::move(e));
            }
        }
        //void set_exception_at_thread_exit(std::exception_ptr e);

    private:
        std::shared_ptr<detail::future_shared_state_box<T>> box;
    };
    
    template<typename T>
    void swap(promise<T>& lhs, promise<T>& rhs) { lhs.swap(rhs); }
}

namespace std {
    template<typename T, typename Alloc>
    struct uses_allocator<my::promise<T>, Alloc> : true_type {};
}

#include <iostream>
#include <thread>

int main() {
    auto p = std::make_shared<my::promise<int>>();
    std::thread([p]{
        std::cout << "B: waiting one second\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "B: setting 17\n";
        p->set_value(17);
        std::cout << "B: 17 was set\n";
    }).detach();
    auto f = p->get_future();
    std::cout << "A: waiting for future result\n";
    auto r = f.get();
    std::cout << "A: got " << r << '\n';
}
====================
=== Random entry ===
====================
asdf
====================
=== Random entry ===
====================
#include <iostream>

int main()
{
    std::cout << "out" << std::endl;
    std::cerr << "err" << std::endl;
    std::clog << "log" << std::endl;
}

====================
=== Random entry ===
====================
download() {
  echo "Downloading $FILE..." && \
  wget -q ${URL} --output-document="${FILE}.part" && \
  mv "${FILE}.part" ${FILE}
  WAIT=$((5 + $RANDOM % 10))
  echo "Wait for ${WAIT} seconds until next download."
  sleep ${WAIT}
}

while read URL ; do
  FILE=`echo ${URL} | cut -d "=" -f 4 | sed "s,\$,.mkv,"`
  if [ -f ${FILE} ] ; then echo "${FILE} already downloaded."
  elif [ -f "${FILE}.part" ] ; then rm "${FILE}.part" && download
  else download
  fi
done < $1

====================
=== Random entry ===
====================
typedef unsigned int codepoint;
 
struct Test {
        static constexpr codepoint difference_latin1_mapping[] = {
            0x20AC,    -1u, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152,    -1u, 0x017D,    -1u,
               -1u, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153,    -1u, 0x017E, 0x0178,
        };
};
 
int main (int argc, char* argv[]) {
    
}
====================
=== Random entry ===
====================
// Making an array with variadic templates

#include <iostream>

template<typename T, typename... Args>
void make_array(Args&&... args) {
    T array[sizeof...(args)] = { args... };
    for(auto&& i : array) {
        std::cout << i << ' ';
    }
}

int main() {
    make_array<int>(1,2,3,4,5,6,7);
}
====================
=== Random entry ===
====================
#include <iostream>
#include <thread>

int main()
{
    std::cout << "Hello GCC " << __VERSION__ << "!" << std::endl;
    std::thread t([](){ std::cout << "Hello Thread!"; });
    t.join();
}
====================
=== Random entry ===
====================
/**
 * Problem 10
 * ----------
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 */


#include <algorithm>
#include <iostream>
#include <vector>
#include <stdint.h>


bool is_prime(uint64_t n, const std::vector<uint64_t> & preceding)
{
    // precondition: "preceding" contains all primes < sqrt(n)

    for (auto p : preceding)
    {
        if ((p * p) > n)
        {
            return true;
        }

        if (n % p == 0)
        {
            return false;
        }
    }
    return true;
}


uint64_t next_prime(const std::vector<uint64_t> & preceding)
{
    if (preceding.empty())
    {
        return 2;
    }

    if (preceding.back() == 2)
    {
        return 3;
    }

    for (uint64_t n = preceding.back() + 2; ; n += 2)
    {
        if (is_prime(n, preceding))
        {
            return n;
        }
    }
}


std::vector<uint64_t> get_primes_below(uint64_t limit)
{
    std::vector<uint64_t> result;
    result.reserve(limit / 2); // no reallocs
    for (;;)
    {
        uint64_t next = next_prime(result);
        if (next >= limit)
        {
            return result;
        }
        result.push_back(next);
    }
}


int main()
{
    auto primes = get_primes_below(2 * 1000 * 1000);
    std::cout << std::accumulate(primes.begin(), primes.end(), uint64_t()) << std::endl;
} // with time22
====================
=== Random entry ===
====================
#include <regex>
#include <sstream>
#include <vector>
#include <iostream>

int main() {
    std::string str = R"d(Would "you" like to have responses to your "questions" sent to you via email?)d";
    std::regex rgx(R"(\"(\w+)\")");
    std::smatch match;
    std::string buffer;
    std::stringstream ss(str);
    std::vector<std::string> strings;
    //Split by whitespaces..
    while(ss >> buffer) 
        strings.push_back(buffer);
    for(auto& i : strings) {
        if(std::regex_match(i,match, rgx)) {
            std::ssub_match submatch = match[1];
            std::cout << submatch.str() << '\n';
        }
    }
}
====================
=== Random entry ===
====================
#include <iostream>
#include <vector>
using namespace std;

class class1
{

public:
    class1() : _cancel(false) { }

//private:
    bool _cancel;

};

class class2
{

public:
    class1 obj1;
};


class class3
{
public:

    void addClass2(class2 _obj2) {
        this->_obj2.push_back(_obj2);
    }
    
    std::vector<class2> _obj2;
};

int main()
{
    class2 object2;
    class3 object3;
    object3.addClass2(object2);
    
    cout << boolalpha << object3._obj2[0].obj1._cancel << endl;
}
====================
=== Random entry ===
====================
#include <cstdio>


void* operator new(std::size_t)
{    
    puts("Hello");
}


void operator delete(void *)
{    
    puts("World!");
}


int main()
{   
    delete new int;
}
====================
=== Random entry ===
====================
class Foo {
public:
  Foo& operator=(const Foo&) = default;
private:
  const int i = 0;
};

int main() {
    Foo f;
    f = f;
}
====================
=== Random entry ===
====================
#include <tuple>
#include <functional>
#include <iostream>

template<typename ...Args>
class Arguments {
    template<int ...> struct seq { };
    template<int N, int ...S> struct gens : gens<N-1, N-1, S...> { };
    template<int ...S> struct gens<0, S...> { typedef seq<S...> type; };    
    template<typename F, int...S> void do_apply_on(const F & f, seq<S...>) { f(std::get<S>(args_)...); }
    std::tuple<Args...> args_;
    
public:
    template<typename ...A> Arguments(A && ...args) : args_{std::forward<A>(args)...} {}

    template<typename F> void apply_on(const F & f)
    {
        do_apply_on(f, typename gens<sizeof...(Args)>::type());
    }
};


int main()
{
    int i;
    Arguments<int, int> arguments(i, 2);
    arguments.apply_on([](int a, int b) { std::cout << a + b; });
}
====================
=== Random entry ===
====================
#include <iostream>
#include <thread>

int main()
{
    std::cout << "Hello GCC " << __VERSION__ << "!" << std::endl;
    std::thread t([](){ std::cout << "Hello Thread!"; });
    t.join();
}
====================
=== Random entry ===
====================
#include <memory>

template <class T>
inline T* to_raw_pointer(T* p) noexcept
{return p;}

template <class T>
inline auto to_raw_pointer(T& p) noexcept -> decltype(to_raw_pointer(p.operator->()))
{return to_raw_pointer(p.operator->());}


std::unique_ptr<int> rval() {return std::unique_ptr<int>{};}

int main()
{
    std::shared_ptr<int> p1(new int(1));
    int* r1 = to_raw_pointer(p1); 
    int* p2 = new int(2);
    int* r2 = to_raw_pointer(p2);
    const std::shared_ptr<int> p3(new int(1));
    const int* r3 = to_raw_pointer(p3); 
    const std::shared_ptr<int> p4(new int(1));
    const int* r4 = to_raw_pointer(p4); 
    std::unique_ptr<int> p5(new int(1));
    int* r5 = to_raw_pointer(p5); 
    const std::unique_ptr<int> p6(new int(1));
    int* r6 = to_raw_pointer(p6); 
    //int* r7 = to_raw_pointer(rval()); //correctly gives compiler error
}
====================
=== Random entry ===
====================
#include <iostream>
#include <string>
#include <vector>


typedef std::vector<std::string> Sentence;


std::ostream& operator<<(std::ostream& os, const Sentence & sentence)
{
    for (typename Sentence::const_iterator i = sentence.begin(), e = sentence.end(); i != e; ++i)
    {
        os << (*i) << " ";
    }
    return os;
}


int main()
{
    Sentence sentence = { "Hello", "from", "GCC", __VERSION__, "!" };    
    std::cout << sentence << std::endl;
}

====================
=== Random entry ===
====================
#include <cstddef>
#include <utility>
#include <iostream>

template <typename T>
struct has_typedef_handle_type {
    // Types "yes" and "no" are guaranteed to have different sizes,
    // specifically sizeof(yes) == 1 and sizeof(no) == 2.
    typedef char yes[1];
    typedef char no[2];
 
    template <typename C>
    static yes& test(typename C::handle_type*);
 
    template <typename>
    static no& test(...);
 
    // If the "sizeof" the result of calling test<T>(0) would be equal to the sizeof(yes),
    // the first overload worked and T has a nested type named foobar.
    static const bool value = sizeof(test<T>(0)) == sizeof(yes);
};

template <bool b, typename T, typename TFallback>
struct handle_enable_if { };

template <typename T, typename TFallback>
struct handle_enable_if<false, T, TFallback> {
	typedef TFallback type;
};

template <typename T, typename TFallback>
struct handle_enable_if<true, T, TFallback>{
	typedef typename T::handle_type type;
};

template <typename T, typename TDx>
struct get_handle_type {
	typedef typename handle_enable_if<has_typedef_handle_type<TDx>::value, TDx, T>::type type;
};

template <typename T>
struct default_handle_deleter {
    void operator () ( T& handle ) {
        // No-op; handle will invoke default destructor upon exist. 
        // You should override this
    }
};

template <typename T>
struct default_handle_null {
	const static T value;
};

template <typename T>
const T default_handle_null<T>::value;

template <typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
class ptrhandle_type;

template <typename T, typename TDx = default_handle_deleter<T>, 
typename get_handle_type<T, TDx>::type nil = default_handle_null<typename get_handle_type<T, TDx>::type>::value >
class handle {
public:
	typedef typename get_handle_type<T, TDx>::type handle_type;
	typedef TDx deleter_type;
	const static handle_type null = nil;

private:
	handle_type res;
	TDx deleter;

	handle ( const handle& nocopy ) {}

public:

	handle ( )
		: res( nil ) {
	}

	handle ( handle_type h )
	: res( h ) {
	}

	handle ( std::nullptr_t ) 
	: res( nil ) {
	}

	handle ( handle_type h, const deleter_type& d )
	: res( h ), deleter( d ) {
	}

	handle ( std::nullptr_t, const deleter_type& d )
	: res( nil ), deleter( d ) {
	}

	handle ( handle_type h, deleter_type&& d ) 
	: res( h ), deleter( std::move( d ) ) {
	}

	handle ( std::nullptr_t, deleter_type&& d ) 
	: res( nil ), deleter( std::move( d ) ) {
	}

	template <typename ...Dx>
	handle ( handle_type h, Dx&&... dx )
		: res( h ), deleter( std::forward<Dx>( dx )... ) {
	}

	template <typename ...Dx>
	handle ( std::nullptr_t, Dx&&... dx )
		: res( nil ), deleter( std::forward<Dx>( dx )... ) {
	}

	handle ( handle&& mov )
	: res( std::move( mov.res )), 
	deleter( std::move( mov.deleter ) ) {
		mov.reset( nullptr );
	}
	
	handle_type get () const {
		return res;
	}

	void reset ( handle_type h ) {
		if ( res != nil )
			deleter( res );
		res = h;
	}

	void reset ( std::nullptr_t ) {
		if ( res != nil )
			deleter( res );
		res = nil;
	}

	handle_type release () {
		handle_type rel = res;
		res = nil;
		return rel;
	}

	void swap ( handle& handler ) {
		std::swap( handler.res, res );
		std::swap( handler.deleter, deleter );
	}

	deleter_type& get_deleter () {
		return deleter;
	}

	const deleter_type& get_deleter () const {
		return deleter;
	}

	handle_type operator* () {
		return get();
	}

	handle_type operator-> () {
		return get();
	}

	operator bool ( ) const { return get() != nil; }
	handle& operator= ( handle&& right ) { reset( right.release() ); return *this; }
	handle& operator= ( handle_type right ) { reset( right ); return *this; }

	operator handle_type () { return get(); }
	operator const handle_type () const { return get(); }
	ptrhandle_type<T, TDx, nil> operator& () { return get_ptrhandle(); }
	ptrhandle_type<T, TDx, nil> get_ptrhandle() { return ptrhandle( *this ); }

	~handle () {
		if ( res != nil )
			deleter( res );
		res = nil;
	}
};

template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( typename handle< T, TDx, nil>::handle_type right, const handle< T, TDx, nil>& left ) { return left.get() == right; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( std::nullptr_t right, const handle< T, TDx, nil>& left ) { return left.get() == nil; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( const handle< T, TDx, nil>& left, const handle< T, TDx, nil>& right ) { return left.get() == right.get(); }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( const handle< T, TDx, nil>& left, const typename handle< T, TDx, nil>::parent_type& right ) { return left.get() == right.get(); }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( const handle< T, TDx, nil>& left, typename handle< T, TDx, nil>::handle_type right ) { return left.get() == right; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator== ( const handle< T, TDx, nil>& left, std::nullptr_t right ) { return left.get() == right; }

template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( typename handle< T, TDx, nil>::handle_type right, const handle< T, TDx, nil>& left ) { return left.get() != right; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( const handle< T, TDx, nil>& left, const typename handle< T, TDx, nil>::parent_type& right ) { return left.get() != right.get(); }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( std::nullptr_t right, const handle< T, TDx, nil>& left ) { return left.get() != nil; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( const handle< T, TDx, nil>& left, const handle< T, TDx, nil>& right ) { return left.get() != right.get(); }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( const handle< T, TDx, nil>& left, typename handle< T, TDx, nil>::handle_type right ) { return left.get() != right; }
template<typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
static bool operator!= ( const handle< T, TDx, nil>& left, std::nullptr_t right ) { return left.get() != nil; }

template< typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
class ptrhandle_type {
public:
	typedef handle<T, TDx, nil> parent_type;
	typedef typename parent_type::handle_type handle_type;

private:
	parent_type* h;
	handle_type a;
	ptrhandle_type(const ptrhandle_type& nocopy) { };
	ptrhandle_type& operator=(const ptrhandle_type& nocopy) { return *this; };

public:
	ptrhandle_type (parent_type& ptr) : h(&ptr), a(ptr.release()) {}
	ptrhandle_type(ptrhandle_type&& mov) {h = mov.h; a = mov.a; mov.h = nullptr;}
	ptrhandle_type& operator=(ptrhandle_type&& mov) {h = mov.h; a = mov.a; mov.h = nullptr; return *this;}
	operator handle_type*() { return &a; }
	operator handle_type&() { return a; }
	~ptrhandle_type () {if ( h ) h->reset( a ); }
};

template< typename T, typename TDx, typename get_handle_type<T, TDx>::type nil>
ptrhandle_type<T, TDx, nil> ptrhandle ( handle<T, TDx, nil>& ptr ) { return ptrhandle_type<T, TDx, nil>( ptr ); }

template <>
struct default_handle_null<int> {
    const static int value;
};

const int default_handle_null<int>::value = 0;

void glDeleteShader ( int* id ) {
   std::cout << "WHAM, POW, BABOW: " << *id << " bites the dust!" << std::endl; 
}

void glNotFaggotDeleteShader ( int& id ){ 
   glDeleteShader( &id );
}

int main ( int argc, char* argv[] ) {
    handle<int> testing = 500;
    std::cout << testing.get() << std::endl;
    testing.release();
    std::cout << testing.get() << std::endl;
    testing = 250;
    std::cout << testing.get() << std::endl;
    
    std::cout << std::endl;
    std::cout << "If this move test works, then testing will show as 0, along with glid!" << std::endl;
    handle<int> x;
    x = std::move( testing );
    
    std::cout << std::endl;
    std::cout << "Oho, fufufu fu~" << std::endl;
    handle<int, decltype( &glNotFaggotDeleteShader )> glid( nullptr, &glNotFaggotDeleteShader );
    handle<int, decltype( &glNotFaggotDeleteShader )> deadglid( nullptr, &glNotFaggotDeleteShader );

    std::cout << testing.get() << std::endl;
    std::cout << glid.get() << std::endl;
    
    std::cout << std::endl;
    std::cout << "Transferring ownership of testing to glid, fufu~" << std::endl;
    glid = testing.release();
    
    std::cout << testing.get() << std::endl;
    std::cout << glid.get() << std::endl;

    std::cout << "Ah ka ka ka! Letting the stack die!" << std::endl;
    
}
====================
=== Random entry ===
====================
struct A {
    static const char* myList[];    
};
const char* A::myList[] = {"item1","item2"};    

#include <iostream>
int main() {
    std::cout << A::myList[0];
}
====================
=== Random entry ===
====================
#include <iostream>
#include <thread>
#include <string>

void greeting(const std::string& message)
{
    std::cout << message << std::endl;
}

int main()
{
    std::cout << "Hello GCC " << __VERSION__ << "!" << std::endl;
    //std::thread t([](){ std::cout << "Hello Thread!"; });
    std::thread t(greeting, "Hello guys");
    t.join();
}
====================
=== Random entry ===
====================
#include "Poco/Stopwatch.h"
#include <algorithm>
#include <iostream>
#include <memory>
#include <mutex>
#include <string>
#include <utility>
#include <tuple>


template<typename T, template<typename> class HookPolicy>
class Proxy : HookPolicy<T>
{    
public:
    Proxy(T & p) : HookPolicy<T>(p), ptr(&p)  { }
    T* operator->() { return ptr; }
    
private:
    T * ptr;    
};


template<typename T, template<typename> class HookPolicy>
class Wrap
{
    typedef Proxy<T, HookPolicy> ProxyType;
    
public:
    template<typename ...Args>
    explicit Wrap(Args && ...inArgs) : mObject(std::forward<Args>(inArgs)...)
    {
    }
    
    /**
     * Apply the "before" and "after" hooks around a single method call.
     */
    ProxyType operator->() const { return ProxyType(mObject); }
    
    /**
     * The execute_around method can be used if you want to apply the
     * "before" and "after" hooks around a group of statements.
     * 
     * This makes sense for e.g. coordinated mutex locking.
     * 
     * Usage example:
     *   Wrap<int, policies::MutexLock> wrap(1);
     *   wrap.execute_around([](int & n) { std::cout << ++n << std::endl; });
     */
    template<typename Fun>
    void execute_around(const Fun & fun) const
    {
        ProxyType scoped_proxy(mObject);
        fun(mObject);
    }
    
private:    
    mutable T mObject;
};


namespace policies {


template<typename T>
struct Inspect
{
    Inspect(T & t) : ptr(&t) { std::cout << "Inspect before: " << *ptr << std::endl; }   
    ~Inspect() { std::cout << "Inspect after: " << *ptr << std::endl; }
    
private:
    T * ptr;
};


template<typename T>
std::mutex & GetMutex(const T & t)
{
    return t.get_mutex();
}


template<typename T>
struct MutexLock
{
    MutexLock(T & t) : data(new Data(GetMutex<T>(t))) { }

private:    
    struct Data
    {
        Data(std::mutex & m) : mutex(m), lock(mutex) {}
        std::mutex & mutex;
        std::unique_lock<std::mutex> lock;
    };
    std::shared_ptr<Data> data;
};


template<typename T>
struct Timer
{
    Timer(T &) : stopwatch(new Poco::Stopwatch) { stopwatch->start(); }    
    ~Timer() { std::cout << "Elapsed: " << stopwatch->elapsed() << " us" << std::endl; }
    
private:
    std::shared_ptr<Poco::Stopwatch> stopwatch;
};


template<template<typename> class ...Args>
struct Group
{
    template<typename T>
    struct Rebind : Args<T>... { Rebind(T & t) : Args<T>(t)... { } };
};


} // namespace policies


int main()
{
    using policies::Group;
    using policies::Timer;
    using policies::MutexLock; 
    using policies::Inspect;
    
    typedef Wrap<std::string, Group<Timer, MutexLock, Inspect>::Rebind> String;
    
    String wrap("test");    
    
    std::cout << "\nSimple method call." << std::endl;
    std::cout << "Size: " << wrap->size() << std::endl;
    
    
    std::cout << "===\nTest execute_around(...)" << std::endl;
    wrap.execute_around([](std::string &s) {
        std::cout << "Start reversing the string...";
        std::reverse(s.begin(), s.end());
        std::cout << " Reverse complete!" << std::endl;
    });
    
    std::cout << "===\nTest Wrap<int>" << std::endl;
    Wrap<int, policies::Timer> wrap_int(1);
    wrap_int.execute_around([](int & n) { std::cout << n++ << std::endl; });
}


// User override
namespace policies {


template<> std::mutex & GetMutex<std::string>(const std::string & )
{
    static std::mutex m;
    return m;
}


} // namespace policies

====================
=== Random entry ===
====================
#include <functional>
#include <iostream>
#include <memory>
#include <mutex>
#include <string>
#include <utility>


#define TRACE std::cout << __PRETTY_FUNCTION__ << std::endl;


template<typename T>
struct Holder
{
    template<typename ...Args>
    explicit Holder(Args && ...inArgs) :
        mObject(std::forward<Args>(inArgs)...)
    {
    }
    
    T mObject;
};


template<typename T, template<typename> class HookPolicy>
class Proxy : private Holder<T>, private HookPolicy<T>
{    
public:
    template<typename ...Args>
    explicit Proxy(Args && ...inArgs) :
        Holder<T>(std::forward<Args>(inArgs)...)
    {
    }
    
    std::shared_ptr<T> operator->() const
    {
        this->before();
        return std::shared_ptr<T>
        (
            const_cast<T*>(&this->mObject),
            std::bind(&HookPolicy<T>::after, static_cast<const HookPolicy<T> *>(this), std::placeholders::_1)
        );
    }
    
    friend std::ostream& operator<<(std::ostream & os, const Proxy<T, HookPolicy> & t)
    {
        auto lock = t.operator->();
        return os << t.mObject;
    }
};


namespace Policies {
    
    
template<typename T>
struct MutexLock
{    
    void before(const T* = nullptr) const
    {
        std::cout << "lock the mutex" << std::endl;
        mtx.lock();
    }
    
    void after(const T* = nullptr)  const
    {
        std::cout << "unlock the mutex" << std::endl;
        mtx.unlock();
    }
    
    mutable std::mutex mtx;
};


} // namespace Policies


int main()
{
    Proxy<std::string, Policies::MutexLock> str;
    str->push_back('a');    
    std::cout << str << std::endl;
    str->clear();
}

====================
=== Random entry ===
====================
#include <future>
#include <thread>
#include <functional>

template <typename Signature>
class async_task;

template <typename Result, typename... Args>
class async_task<Result(Args...)> {
public:
    using signature_type = Result(Args...);

    template <typename Fun>
    explicit async_task(Fun&& fun)
    : fun(std::forward<Fun>(fun)) {}

    std::future<Result> operator()(Args... args) const {
        std::packaged_task<signature_type> task(fun);
        auto result = task.get_future();
        std::thread(std::move(task)).detach(); // no cancellation? :(
        return result;
    }
    
private:
    std::function<signature_type> fun;
};

#include <random>
#include <chrono>
#include <iostream>

int main()
{
    async_task<int()> async_d6{[&]() -> int {
        std::random_device dev;
        std::mt19937 generator{dev()};
        std::uniform_int_distribution<int> distribution{1, 6};
        auto r = distribution(generator);
        std::this_thread::sleep_for(std::chrono::seconds(r));
        std::cout << "Slept for " << r << " seconds.\n"; // race on purpose
        return r;
    }};
    auto die1 = async_d6();
    auto die2 = async_d6();
    std::cout << "Total is: " << die1.get() + die2.get();
}
====================
=== Random entry ===
====================
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <memory>
#include <mutex>
#include <stdexcept>
#include <thread>


struct Blocker
{
    Blocker(unsigned n) : n(n) {}

    void notify()
    {
        std::cout << "notify()" << std::endl;
        std::unique_lock<std::mutex> lock(m);
        if (n)
        {
            n--;
        }
        c.notify_all();
    }

    void wait()
    {
        std::cout << "Gonna wait." << std::endl;
        std::unique_lock<std::mutex> lock(m);
        std::cout << "n is " << n << " before wait." << std::endl;
        while (n)
        {
            c.wait(lock);
            std::cout << "Received notification!" << std::endl;
        }
    }

    unsigned n;
    std::mutex m;
    std::condition_variable c;
};

template<typename Callback>
void async_operation(const Callback & cb)
{
    std::thread(cb).join();
}


int main()
{
    Blocker b(1);
    async_operation([&]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        std::cout << "Finished my work. Gonna notify." << std::endl;
        b.notify();
        std::cout << "Did the notify." << std::endl;
    });
    b.wait();

    std::cout << "End of program." << std::endl;
}

====================
=== Random entry ===
====================
#include <iostream>

int main()
{
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
    std::cout << "Hello World!" << std::endl;
}//
====================
=== Random entry ===
====================
#include <iostream>
#include <iomanip>

int main() {
    double d = 600851475143;
    std::cout.precision(1000);
    std::cout << d;
}
====================
=== Random entry ===
====================
#include <iostream>

struct foo {
    foo() = default;
    foo(foo&&) { std::cout << "Hey, I'm moving"; }
};

foo f() {
   foo x;
   return std::move(x);
}

int main() {
    foo a = f();
    (void)a;
}
====================
=== Random entry ===
====================
/**
 * Problem 10
 * ----------
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 */


#include <algorithm>
#include <iostream>
#include <vector>
#include <stdint.h>


bool is_prime(uint64_t n, const std::vector<uint64_t> & preceding)
{
    // precondition: "preceding" contains all primes < sqrt(n)

    for (auto p : preceding)
    {
        if ((p * p) > n)
        {
            return true;
        }

        if (n % p == 0)
        {
            return false;
        }
    }
    return true;
}


uint64_t next_prime(const std::vector<uint64_t> & preceding)
{
    if (preceding.empty())
    {
        return 2;
    }

    if (preceding.back() == 2)
    {
        return 3;
    }

    for (uint64_t n = preceding.back() + 2; ; n += 2)
    {
        if (is_prime(n, preceding))
        {
            return n;
        }
    }
}


uint64_t get_primes_below(uint64_t limit)
{
    uint64_t sum = 0;
    std::vector<uint64_t> result;
    result.reserve(limit / 2); // no reallocs
    for (;;)
    {
        uint64_t next = next_prime(result);
        sum += next;
        if (next >= limit)
        {
            return sum;
        }
        result.push_back(next);
    }
}


int main()
{
    std::cout << get_primes_below(2 * 1000 * 1000) << std::endl;
} // with time
====================
=== Random entry ===
====================
#include <iostream>

int main() {
    
    char a = 'h';
    
    std::cout << (a - '0') << " != " << +a;
    
}
====================
=== Random entry ===
====================
#include <iostream>
int main() {
    int i = 42;
    [&i](int i) { std::cout << i; }(0);
}
====================
=== Random entry ===
====================
#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <iterator>
#include <initializer_list>
#include <type_traits>

// A simple (incomplete) wrapper for string objects which is used to demonstrate
// how initializer_lists work with objects
class StringHolder{
protected:
    std::string myStr;
public:
    StringHolder() : myStr()
        { std::cout << "StringHolder empty constructor" << std::endl; }
    StringHolder(const char* sInit) : myStr(sInit)
        { std::cout << "StringHolder(const char*) constructor, init string: " << sInit << std::endl; }
    // Copy-construct
    StringHolder(const StringHolder & copyFrom) : myStr(copyFrom.myStr)
        { std::cout << "StringHolder (*COPY*) Constructor called, made COPY of: " << myStr << std::endl; }
    // Move-construct
    StringHolder(StringHolder && moveFrom)
     : myStr(std::forward<std::string>(moveFrom.myStr))
    {
        // Note we already move-constructed string myStr, which has its own move constructor
        std::cout << "StringHolder (*MOVE*) Constructor called, now owning: " << myStr << std::endl;
    }
    ~StringHolder()
    { std::cout << "~StringHolder ~destructor~, string contents: " << myStr << std::endl; }
    
    // Copy-Assignment
    StringHolder& operator=(const StringHolder& copyFrom)
    {
        // Make sure we are not assigning to ourself
        if (this != &copyFrom)
        {
            /* Clear our values, release resources */
            myStr.clear();
            /* Copy in new values/resources */
            myStr = copyFrom.myStr;

            std::cout << "StringHolder operator=(COPY) called, made COPY of: " << myStr << std::endl;
        }
        return *this;
    }
    // Move-Assignment
    StringHolder& operator=(StringHolder&& moveFrom)
    {
        // Make sure we are not assigning to ourself
        if (this != &moveFrom)
        {
            // Move-assign myStr (we invoke it via operator= just so we're clear on the std::forward() definition
            myStr.operator=(std::forward<std::string>(moveFrom.myStr));

            std::cout << "StringHolder operator=(MOVE) called, now owning: " << myStr << std::endl;
        }
        return *this;
    }
};


// initializer_list Proxy - Using Insert Iterators
template <typename InsIter, typename LType>
void insertInitListProxyI(InsIter inserter, std::initializer_list<LType> il)
{
    // construct the items in-place
    for (auto it = il.begin(); it < il.end(); ++it)
    	*inserter++ = *it;
}


int main ()
{
    std::vector<StringHolder> myVec;

    // Reserve some space so no vector resizing takes place
    myVec.reserve(20);

    std::cout << "---------- Pushing data on vector ----------\n" << std::endl;

    myVec.push_back("charstr");

    std::cout << "\n------ Now invoking initializer_list insertion ------\n" << std::endl;

    myVec.insert(myVec.end(), {"str1", "str2"});

    std::cout << "\n------ Now invoking initializer_list proxy ------\n" << std::endl;

    // Here we could pre-allocate the needed space before the call:
    //myVec.reserve(myVec.size() + 3);

    // insert_iterator version of initializer_list Proxy:
    insertInitListProxyI(std::back_inserter(myVec), {"str3", "str4", "str5"});

    std::cout << "\n---------- Vector Destruction looming ----------\n" << std::endl;

    return 0;
}

====================
=== Random entry ===
====================
#include <boost/phoenix/core.hpp>
#include <boost/phoenix/operator.hpp>
#include <boost/phoenix/function.hpp>
#include <algorithm>
#include <iostream>
#include <string>


boost::phoenix::expression::argument<1>::type arg1;
struct flip_impl
{
    template<typename Arg>
    struct result { typedef Arg type; };
    
    template<typename Arg>
    typename result<Arg>::type operator()(Arg arg) const
    {
        using std::begin;
        using std::end;
        std::reverse(begin(arg), end(arg));
        return arg;
    }
};


boost::phoenix::function<flip_impl> flip;


int main()
{
    std::string abc = "abc";
    std::cout << flip(abc)() << std::endl;
}

====================
=== Random entry ===
====================
#include <cassert>
#include <iostream>

enum class Color {
    Begin,
    Red = Begin,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet,
    End
};

struct Colors{};
Color begin(Colors) { return Color::Begin; }
Color end  (Colors) { return Color::End; }
Color operator*(Color c) { return c; }


Color operator++(Color & c)
{
    assert(c < Color::End);
    return c = static_cast<Color>(static_cast<int>(c) + 1);
}

std::ostream& operator<<(std::ostream& os, Color c)
{
    switch (c)
    {
        case Color::Red:    return os << "Red";
        case Color::Orange: return os << "Orange";
        case Color::Yellow: return os << "Yellow";
        case Color::Green:  return os << "Green";
        case Color::Blue:   return os << "Blue";
        case Color::Indigo: return os << "Indigo";
        case Color::Violet: return os << "Violet";
        default:            return os << "(Invalid Color)";
    }
}

int main()
{
    for (auto i : Colors{})
    {
        std::cout << i << std::endl;
    }
}
====================
=== Random entry ===
====================
#include <future>
#include <iostream>
#include <boost/variant.hpp>
#include <memory>
#include <vector>

// metaprogramming boilerplate:

// sequences of offsets:
template<std::size_t...>
struct seq {};
template<std::size_t Min, std::size_t Max, std::size_t... s>
struct make_seq:make_seq<Min, Max-1, Max-1, s...> {};
template<std::size_t Min, std::size_t... s>
struct make_seq<Min, Min, s...> {
    typedef seq<Min, s...> type;
};
template<std::size_t Max, std::size_t Min=0>
using MakeSeq = typename make_seq<Min, Max>::type;

// utility function to do a sequence of tasks in a particular order:
void do_in_order() {}
template<typename F0, typename... Fs>
void do_in_order( F0&& f0, Fs&&... fs ) {
    std::forward<F0>(f0)();
    do_in_order( std::forward<Fs>(fs)... );
}

// stores a bundle of types:
template<typename...>
struct type_list {};

// Copies types from one template<typename...> to another:
template<typename L, template<typename...>class Targ>
struct copy_types;
template<template<typename...>class L, typename... Ts, template<typename...>class Targ>
struct copy_types< L<Ts...>, Targ > {
    typedef Targ<Ts...> type;
};
template<typename L, template<typename...>class Targ>
using CopyTypes = typename copy_types<L, Targ>::type;

// In some cases, we want different behavior based on phase
// Phases are types, and all_phase is the default
struct all_phases {};

struct empty {};

// For a given node type T, the default data type is T in all phases:
template<typename T>
struct data_type_all_phase {
    typedef T type;
};
template<typename T, typename phase=all_phases>
struct data_type:data_type_all_phase<T> {};

template<typename T, typename phase=all_phases>
using DataType = typename data_type<T, phase>::type;

// For a given node type T, the default legal child node types is T:
template<typename T>
struct child_types_all_phase {
    typedef type_list<T> types;
};
template<typename T, typename phase=all_phases>
struct child_types:child_types_all_phase<T> {};

template<typename T, typename phase=all_phases>
using ChildTypes = typename child_types<T, phase>::types;

template<typename T>
struct child_container_all_phase {
    template<typename U>
    using container = std::vector<U>;
};
template<>
struct child_container_all_phase<empty> {
    template<typename U>
    using container = empty;
};
template<typename T,typename phase=all_phases>
struct child_container:child_container_all_phase<T> {};
template<typename T,typename U,typename phase=all_phases>
using ChildContainer = typename child_container<U, phase>::template container<U>;

// All TreeBase<phase, Ts...> MUST be Tree<phase, Ts...>:
template<typename phase, typename...Ts>
struct TreeBase {
    virtual ~TreeBase() {}
};
template<typename phase>
struct MakeTreeBase {
    template<typename... Ts>
    using Type = TreeBase<phase, Ts...>;
};

template<typename T, typename phase=all_phases>
struct TypedTree {
    DataType<T, phase> data;
    ChildContainer< T, CopyTypes< ChildTypes<T>, MakeTreeBase<phase>::template Type >, phase > children;
    template<typename U>
    TypedTree( U&& d ):data(std::forward<U>(d)) {};
    TypedTree():data() {};
};
template<typename phase, typename...Ts>
struct Tree:TreeBase<phase, Ts...> {
    boost::variant< TypedTree< empty, phase >, TypedTree< Ts, phase >... > node;
    template<typename U>
    TypedTree<U,phase>* get_node() {
        return boost::get< TypedTree<U, phase> >( &node );
    }
    template<typename U>
    TypedTree<U,phase> const* cget_node() const {
        return boost::get< TypedTree<U, phase> >( &node );
    }
    template<typename U>
    TypedTree<U,phase> const* get_node() const {
        return boost::get< TypedTree<U, phase> >( &node );
    }
    template<typename U>
    DataType<U, phase>* get_data() {
        auto* match = get_node<U>();
        if (!match)
            return nullptr;
        else
            return &match->data;
    }
    template<typename U>
    DataType<U, phase> const* cget_data() const {
        auto* match = get_node<U>();
        if (!match)
            return nullptr;
        else
            return &match->data;
    }
    template<typename U>
    DataType<U, phase> const* get_data() const {
        return cget_data();
    }
    template<typename U>
    auto get_children()->decltype( &get_node<U>()->children ) {
        auto* match = get_node<U>();
        if (!match)
            return nullptr;
        else
            return &match->children;
    }
    template<typename U>
    auto cget_children()->decltype( &get_node<U>()->children ) const {
        auto* match = get_node<U>();
        if (!match)
            return nullptr;
        else
            return &match->children;
    }
    template<typename U>
    auto get_children()->decltype( &get_node<U>()->children ) const {
        return cget_children<U>();
    }
    template<typename U, typename V>
    void set_type( V&& data ) {
        node = TypedTree<U, phase>( std::forward<V>(data) );
    }
    template<typename U>
    void set_type() {
        node = TypedTree<U, phase>();
    }
};
template<typename phase, typename...Ts>
Tree<phase, Ts...>& FromBase( TreeBase<phase, Ts...>& base ) { return static_cast<Tree<phase, Ts...>&>(base); }
template<typename phase, typename...Ts>
Tree<phase, Ts...> const& FromBase( TreeBase<phase, Ts...> const& base ) { return static_cast<Tree<phase, Ts...> const&>(base); }

template<std::size_t n>
struct phase {};
struct phase0 {};

Tree< phase0, int, double > test;

struct printer {
    template<typename T>
    void operator()( T const* t ) const {
        std::cout << t;
        if (t)
            std::cout << *t;
        std::cout << "\n";
    }
};

template<typename... Ts, typename Tree, typename Print>
void dump_state(Tree&& tree, Print&& print = printer()) {
    do_in_order( [&]{
        print( tree.template get_data<Ts>() );
    }... );
}

int main() {
    dump_data<int, double>( test, printer );
    std::cout << "test complete\n";
}
====================
=== Random entry ===
====================
#include <type_traits>
#include <iostream>
#include <iomanip>

int main() {
    int x[42];
    std::cout << std::boolalpha << std::is_same<decltype(x), int*>::value;
}
====================
=== Random entry ===
====================

// functions are undefined and thus unoptimizable
void disappear(int);
int* get_data();
int get_length();

int* a = get_data();
int length = get_length();

// Utility for ASM mark points.
template<int> void ____ASM__MARKER____();
#define ASM_MARKER() ____ASM__MARKER____< __COUNTER__ >()


#ifdef USE_ITERATOR


// Use wrapper
struct Wrap
{
    Wrap(int* data) : data_(data) {}
    
    Wrap& operator++()
    {
        ++data_;
        return *this;
    }
    
    const int& operator*() const { return *data_; }
    int& operator*() { return *data_; }
    
    friend bool operator!=(const Wrap& lhs, const Wrap& rhs)
    {
        return lhs.data_ != rhs.data_;
    }
    
    int* data_;
};

void process(Wrap begin, Wrap end)
{
    ASM_MARKER();
    for (Wrap it = begin; ASM_MARKER(), it != end; ASM_MARKER(), ++it)
    {
        ASM_MARKER();
        disappear(*it);
    }
    ASM_MARKER();
}


#else


// Use simple pointer
void process(int* begin, int* end)
{
    ASM_MARKER();
    for (int* it = begin; ASM_MARKER(), it != end; ASM_MARKER(), ++it)
    {
        ASM_MARKER();
        disappear(*it);        
    }
    ASM_MARKER();
}


#endif


int main()
{
    
#ifdef USE_ITERATOR
    process(Wrap(a), Wrap(a + length));
#else
    process(a, a + length);
#endif
}


====================
=== Random entry ===
====================
#include <iostream>
#include <string>
#include <vector>


using Sentence = std::vector<std::string>;


std::ostream& operator<<(std::ostream& os, const Sentence & sentence)
{
    for (const auto & word : sentence)
    {
        os << word << " ";
    }
    return os;
}


int main()
{
    Sentence sentence = { "Hello", "from", "GCC", __VERSION__, "!" };    
    std::cout << sentence << std::endl;
}
//aw
====================
=== Random entry ===
====================
#include "tbb/concurrent_queue.h"
#include <chrono>
#include <condition_variable>
#include <functional>
#include <future>
#include <mutex>
#include <iostream>
#include <thread>
#include <utility>


template<typename T>
struct Shared
{
    template<typename ...Args>
    Shared(Args && ...args) :
        mQuit(),
        mObj(std::forward<Args>(args)...),
        mThread(std::bind(&Shared<T>::consume, this))
    {
    }

    ~Shared()
    {
        {
            std::unique_lock<std::mutex> lock(mMutex);
            mQuit = true;
            mCondition.notify_all();
        }
        mThread.join();
    }
    
    template<typename F>
    auto execute(F f) -> std::future<typename std::result_of<F(T&)>::type>
    {
        auto promisePtr = std::make_shared<std::promise<typename std::result_of<F(T&)>::type>>();
        std::shared_ptr<void> notify_later(nullptr, [this](void*) { this->mCondition.notify_one(); });
        std::unique_lock<std::mutex> lock(mMutex);
        mQueue.push(std::bind([=]() -> void {
            try {
                promisePtr->set_value(f(mObj));
            } catch (...) {
                promisePtr->set_exception(std::current_exception());
            }
        }));
        return promisePtr->get_future();
    }

private:
    Shared(const Shared&) = delete;
    Shared& operator=(const Shared&) = delete;
    
    typedef std::function<void()> Task; // type erased in order to allow various types of tasks

    void consume()
    {
        while (!mQuit)
        {
            std::unique_lock<std::mutex> lock(mMutex);
            mCondition.wait(lock);
            Task task;
            if (mQueue.try_pop(task)) {
                task();
            }
        }
    }

    std::atomic<bool> mQuit;
    std::condition_variable mCondition;
    std::mutex mMutex;
    tbb::concurrent_queue<Task> mQueue; // lockless queue would be better
    T mObj;
    std::thread mThread;
};

struct Car
{
    unsigned age() const { return 777; }
    unsigned weight() const { return 888; }
};

int main()
{
    Shared<Car> a,b,c;    
    auto age_a = a.execute([](Car & c) -> unsigned { return c.age(); });
    auto age_b = b.execute([](Car & c) -> unsigned { return c.age(); });
    auto age_c = c.execute([](Car & c) -> unsigned { return c.age(); });
    std::cout << age_a.get() << std::endl;
    std::cout << age_b.get() << std::endl;
    std::cout << age_c.get() << std::endl;
}

====================
=== Random entry ===
====================
#include <iostream>
#include <string>

int main()
{
    std::cout << sizeof(std::string) << std::endl;
}
====================
=== Random entry ===
====================
#include <memory>

void foo2() {}

int main()
{
    int a = 0;
    std::shared_ptr<void*> ptr(nullptr, [&](void*){foo2(a); });
}
====================
=== Random entry ===
====================
#include "boost/variant.hpp"
#include <iostream>
#include <string>


namespace policies {


template<class T> struct PolicyInterface
{
    void operator()(std::ostream & os, const std::string & s) const
    {
        static_cast<const T&>(*this).invoke(os, s);
    }
};


struct PolicyVisitor : boost::static_visitor<>
{
    PolicyVisitor(std::ostream & os, const std::string & s) : os(os), s(s) {}

    template<typename C>
    void operator()(const PolicyInterface<C> & c) const
    {
        c(os, s);
    }
    
    std::ostream & os;
    const std::string & s;
};


template<typename P, typename ...Args>
void RunPolicy(const P & p, Args && ...args)
{
    PolicyVisitor v(std::forward<Args>(args)...);
    p.apply_visitor(v);
}


} // namespace policies


namespace policies {
namespace compression {


struct Plain : PolicyInterface<Plain>
{
    void invoke(std::ostream & os, const std::string & s) const
    {
        os << "plain[" << s << "]";
    }
};


struct Zip : PolicyInterface<Zip>
{
    void invoke(std::ostream & os, const std::string & s) const
    {
        os << "zip[" << s << "]";
    }
};


typedef boost::variant<Plain, Zip> Policy;


} } // namespace policies::compression


class Archive
{
    typedef policies::compression::Policy CompressionPolicy;
    mutable CompressionPolicy comp;
    
public:
    Archive(const CompressionPolicy & c) : comp(c)
    {
    }
    
    void archive(std::ostream & os, const std::string & s)
    {
        RunPolicy(comp, os, s);
    }    
};


int main()
{
    using policies::compression::Zip;
    using policies::compression::Plain;
    
    Archive zip_archive(Zip{});
    zip_archive.archive(std::cout, "ziptest");
    
    std::cout << std::endl;
    
    Archive plain_archive(Plain{});
    plain_archive.archive(std::cout, "plaintest");
}

