+ g++ -std=c++11 -O2 -Wall -pedantic -pthread main.cpp
main.cpp: In function ‘int main()’:
main.cpp:20:7: error: no match for call to ‘(std::_Bind<void (*(std::unique_ptr<Test, std::default_delete<Test> >))(Test&&)>) ()’
     f();
       ^
In file included from /usr/include/c++/4.8/memory:79:0,
                 from main.cpp:2:
/usr/include/c++/4.8/functional:1280:11: note: candidates are:
     class _Bind<_Functor(_Bound_args...)>
           ^
/usr/include/c++/4.8/functional:1351:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) [with _Args = {_Args ...}; _Result = _Result; _Functor = void (*)(Test&&); _Bound_args = {std::unique_ptr<Test, std::default_delete<Test> >}]
  operator()(_Args&&... __args)
  ^
/usr/include/c++/4.8/functional:1351:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1347:37: error: invalid initialization of reference of type ‘Test&&’ from expression of type ‘std::unique_ptr<Test, std::default_delete<Test> >’
  = decltype( std::declval<_Functor>()(
                                     ^
/usr/include/c++/4.8/functional:1365:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const [with _Args = {_Args ...}; _Result = _Result; _Functor = void (*)(Test&&); _Bound_args = {std::unique_ptr<Test, std::default_delete<Test> >}]
  operator()(_Args&&... __args) const
  ^
/usr/include/c++/4.8/functional:1365:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1361:53: error: invalid initialization of reference of type ‘Test&&’ from expression of type ‘const std::unique_ptr<Test, std::default_delete<Test> >’
          typename add_const<_Functor>::type>::type>()(
                                                     ^
/usr/include/c++/4.8/functional:1379:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (*)(Test&&); _Bound_args = {std::unique_ptr<Test, std::default_delete<Test> >}]
  operator()(_Args&&... __args) volatile
  ^
/usr/include/c++/4.8/functional:1379:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1375:70: error: invalid initialization of reference of type ‘Test&&’ from expression of type ‘volatile std::unique_ptr<Test, std::default_delete<Test> >’
                        typename add_volatile<_Functor>::type>::type>()(
                                                                      ^
/usr/include/c++/4.8/functional:1393:2: note: template<class ... _Args, class _Result> _Result std::_Bind<_Functor(_Bound_args ...)>::operator()(_Args&& ...) const volatile [with _Args = {_Args ...}; _Result = _Result; _Functor = void (*)(Test&&); _Bound_args = {std::unique_ptr<Test, std::default_delete<Test> >}]
  operator()(_Args&&... __args) const volatile
  ^
/usr/include/c++/4.8/functional:1393:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:1389:64: error: invalid initialization of reference of type ‘Test&&’ from expression of type ‘const volatile std::unique_ptr<Test, std::default_delete<Test> >’
                        typename add_cv<_Functor>::type>::type>()(
                                                                ^
